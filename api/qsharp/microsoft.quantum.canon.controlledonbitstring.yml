### YamlMime:QSharpType
uid: microsoft.quantum.canon.controlledonbitstring
name: ControlledOnBitString
type: function
namespace: microsoft.quantum.canon
summary: >-
  Gibt einen einheitlichen Vorgang zurück, der ein Oracle auf das Ziel Register anwendet, wenn der Steuerelement Registrierungs Zustand einer angegebenen Bitmaske entspricht.


  Die Ausgabe dieser Funktion ist ein Vorgang, der durch eine einheitliche Transformation $U $ dargestellt werden kann, sodass \begin{align} U \ket{b_0 B_1 \cdots b_ {n-1}} \ket{\psi} = \ket{b_0 B_1 \cdots b_ {n-1}} \otimes \begin{Cases} V \ket{\psi} & \textrm{if} (b_0 B_1 \cdots b_ {n-1}) = \texttt{Bits} \\ \\ \ket{\psi} & \textrm{otherwits} \end{Cases}, \end{align}, wobei $V $ eine einheitliche Transformation ist, die die Aktion des `oracle` Vorgangs darstellt.
remarks: >-
  Das von angegebene Muster `bits` ist möglicherweise kürzer als `controlRegister` . in diesem Fall werden zusätzliche Steuerungs-Qubits ignoriert (d. h., Sie werden nicht für "$ \ket {0} $" und "$ \ket $" gesteuert {1} ).

  Wenn `bits` länger als ist `controlRegister` , wird ein Fehler ausgelöst.


  Bei einem booleschen Array `bits` und einem einheitlichen Vorgang `oracle` ist die Ausgabe dieser Funktion ein Vorgang, der die folgenden Schritte ausführt:


  * wenden `X` Sie einen Vorgang auf jedes Qubit des Steuerelement Registrierungs Elements an, das dem- `false` Element von entspricht `bits` .

  * `Controlled oracle`auf das Steuerelement und die Ziel Register anwenden;

  * wenden `X` Sie einen Vorgang auf jedes Qubit des Steuerelement Registrierungs Elements an, das dem- `false` Element des-Elements entspricht, `bits` um das Steuerelement in den ursprünglichen Zustand zurückzukehren.


  Die Ausgabe des `Controlled` funktors ist ein Sonderfall von `ControlledOnBitString` , wobei `bits` gleich ist `[true, ..., true]` .
examples: >-
  Die folgenden Code Ausschnitte sind gleichwertig:


  ```qsharp

  (ControlledOnBitString(bits, oracle))(controlRegister, targetRegister);

  ```


  and


  ```qsharp

  within {
      ApplyPauliFromBitString(PauliX, false, bits, controlRegister);
  } apply {
      Controlled oracle(controlRegister, targetRegister);
  }

  ```


  Der folgende Code bereitet den Status $ \frac {1} {2} (\ket {00} -\ket {01} + \ket {10} + \ket {11} ) $:


  ```qsharp

  using (register = Qubit[2]) {
      ApplyToEach(H, register);
      (ControlledOnBitString([false], Z))(register[0..0], register[1]);
  }

  ```
syntax: "function ControlledOnBitString (bits : Bool[], oracle : ('T => Unit is Adj + Ctl)) : ((Qubit[], 'T) => Unit is Adj + Ctl)"
input:
  content: "(bits : Bool[], oracle : ('T => Unit is Adj + Ctl))"
  types:
  - name: bits
    summary: Die Bitzeichenfolge, für die der angegebene einheitliche Vorgang gesteuert werden soll.
    isArray: true
    isPrimitive: true
    uid: Bool
  - name: oracle
    summary: Der auf das Ziel Register anzuwendende einheitliche Vorgang.
    isOperation: true
    input:
      types:
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
output:
  content: ((Qubit[], 'T) => Unit is Adj + Ctl)
  types:
  - summary: Ein einheitlicher Vorgang, `oracle` der für das Ziel Register gilt, wenn der Steuerelement Registrierungs Zustand der Bitmaske entspricht `bits` .
    isOperation: true
    input:
      types:
      - isArray: true
        isPrimitive: true
        uid: Qubit
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
metadata:
  ms.openlocfilehash: 3064af5cc25b8d5a63f57d62803b8484d2f93d2c
  ms.sourcegitcommit: d6ac6f4345be0dd68f1bcd944f44b08e7a3cf346
  ms.translationtype: MT
  ms.contentlocale: de-DE
  ms.lasthandoff: 09/02/2020
  ms.locfileid: "89356642"
