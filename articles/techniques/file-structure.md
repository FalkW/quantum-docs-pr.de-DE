---
title: 'Q #-Programmübersicht: q #-Techniken | Microsoft-Dokumentation'
description: 'Q #-Programmübersicht-q #-Techniken'
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: e8f52e6b0d4382331665a8e845ef19a3a1beabf9
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/29/2020
ms.locfileid: "76820826"
---
# <a name="q-program-overview"></a><span data-ttu-id="6d115-103">Q#-Programmübersicht</span><span class="sxs-lookup"><span data-stu-id="6d115-103">Q# program overview</span></span>

<span data-ttu-id="6d115-104">F # ist eine skalierbare, domänenspezifische Programmiersprache mit mehreren Paradigmen für das Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="6d115-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="6d115-105">F # ist eine Quantum-Programmiersprache, mit der Sie beschreiben können, wie Anweisungen auf Quantum-Computern ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6d115-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="6d115-106">Die Computer, die als Zielgruppe eingesetzt werden können, reichen von Simulatoren bis zur eigentlichen Quantum-Hardware.</span><span class="sxs-lookup"><span data-stu-id="6d115-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="6d115-107">F # ist skalierbar: Es kann verwendet werden, um einfache Demonstrationsprogramme wie Teleports zu schreiben, die auf wenigen Qubits ausgeführt werden. Sie unterstützt aber auch das Schreiben großer, anspruchsvoller Programme, wie z. b. Simulationen komplexer Moleküle, die große Computer mit Millionen von Qubits erfordern.</span><span class="sxs-lookup"><span data-stu-id="6d115-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="6d115-108">Auch wenn große physische Computer noch in der Zukunft liegen, ermöglicht Q # es Programmierern, jetzt komplexe Quantum-Algorithmen zu programmieren.</span><span class="sxs-lookup"><span data-stu-id="6d115-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="6d115-109">Weitere Informationen finden Sie unter Unterstützung für verschiedene Aufgaben, z. b. Debuggen, Profilerstellung, Ressourcenschätzung und bestimmte spezielle Simulationen auf skalierbare Weise.</span><span class="sxs-lookup"><span data-stu-id="6d115-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="6d115-110">Aus technischer Sicht kann ein Quantum-Programm als ein bestimmter Satz klassischer Funktionen angesehen werden, die beim Aufrufen von Quantum-Verbindungen als Nebeneffekte generieren.</span><span class="sxs-lookup"><span data-stu-id="6d115-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="6d115-111">Eine wichtige Konsequenz dieser Ansicht besteht darin, dass ein in Q # geschriebenes Programm Qubits selbst nicht direkt modelliert, sondern vielmehr beschreibt, wie ein klassischer Steuerungscomputer mit diesen Qubits interagiert.</span><span class="sxs-lookup"><span data-stu-id="6d115-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="6d115-112">Entwurfs bedingt definiert f # daher nicht die Quantum-Zustände oder andere Eigenschaften von Quantum-Mechanismen direkt, sondern indirekt durch die Aktion der verschiedenen Unterroutinen, die in der Sprache definiert sind.</span><span class="sxs-lookup"><span data-stu-id="6d115-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="6d115-113">Sehen Sie sich beispielsweise den Status $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ an, der im Handbuch für die [Quantum Computing-Konzepte](xref:microsoft.quantum.concepts.intro) erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="6d115-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="6d115-114">Um diesen Status in Q # vorzubereiten, verwenden wir die Fakten, die die Qubits im $ \ket{0}$ State initialisiert werden, und die $ \ket{+} = h\ket{0}$, wobei $H $ die Hadamard-Transformation ist:</span><span class="sxs-lookup"><span data-stu-id="6d115-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="6d115-115">Q #-Tranformationen von Quantum-Zuständen</span><span class="sxs-lookup"><span data-stu-id="6d115-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="6d115-116">Wichtig: beim Schreiben des obigen Programms haben wir nicht explizit auf den Bundesstaat in Q # verwiesen, sondern vielmehr beschrieben, wie der Zustand von unserem Programm *transformiert* wurde.</span><span class="sxs-lookup"><span data-stu-id="6d115-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="6d115-117">Ähnlich wie ein Grafik-Shader-Programm eine Beschreibung von Transformationen zu jedem Scheitelpunkt sammelt, sammelt ein Quantum-Programm in Q # Transformationen in Quantum-Zuständen.</span><span class="sxs-lookup"><span data-stu-id="6d115-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="6d115-118">Dies ermöglicht es uns, unabhängig davon, was ein Quantum-Status *ist* , auch auf jedem Zielcomputer zu sein, der je nach Computer unterschiedliche Interpretationen aufweisen kann.</span><span class="sxs-lookup"><span data-stu-id="6d115-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="6d115-119">Aus der Perspektive eines Q #-Programms ist ein Qubit ein vollständig undurchsichtiger Verweis auf die interne Struktur eines Ziel Computers.</span><span class="sxs-lookup"><span data-stu-id="6d115-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="6d115-120">Ein Q #-Programm kann nicht auf den Zustand eines Qubit, seine Darstellung auf einem Zielcomputer oder auch darauf hinweisen, ob es sich um das gleiche Qubit wie jedes andere Qubit handelt, das für das Programm verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="6d115-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="6d115-121">Ein Programm kann z. b. Vorgänge wie `Measure` zum Erlernen von Informationen aus einem Qubit und zum Abrufen von Vorgängen, z. b. `X` und `H`, um auf den Zustand eines Qubit zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="6d115-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="6d115-122">Diese Vorgänge haben keine intrinsische Definition innerhalb der Sprache und werden nur durch den Zielcomputer, der zum Ausführen eines bestimmten Q #-Programms verwendet wird, konkretisiert.</span><span class="sxs-lookup"><span data-stu-id="6d115-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="6d115-123">Ein Q #-Programm kombiniert diese Vorgänge neu, wie von einem Zielcomputer definiert, um neue Vorgänge auf höherer Ebene zu erstellen, um die Quantum-Berechnung auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="6d115-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="6d115-124">Auf diese Weise vereinfacht f # das Ausdrücken der Logik zugrunde liegenden Quantum-und Hybrid-Quantum-Hybrid Algorithmen und ist gleichzeitig in Bezug auf die Struktur eines Ziel Computers oder Simulators allgemein.</span><span class="sxs-lookup"><span data-stu-id="6d115-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="6d115-125">F #-Vorgänge und-Funktionen</span><span class="sxs-lookup"><span data-stu-id="6d115-125">Q# operations and functions</span></span>

<span data-ttu-id="6d115-126">Konkret besteht ein Q #-Programm aus mindestens einem *Vorgang*, einer oder mehreren *Funktionen*und benutzerdefinierten Typen.</span><span class="sxs-lookup"><span data-stu-id="6d115-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="6d115-127">Vorgänge werden verwendet, um die Transformationen des Zustands eines Quantum-Computers zu beschreiben, und sind der grundlegendste Baustein von Q #-Programmen.</span><span class="sxs-lookup"><span data-stu-id="6d115-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="6d115-128">Jeder in Q # definierte Vorgang kann dann eine beliebige Anzahl anderer Vorgänge aufzurufen, einschließlich der integrierten System *internen Vorgänge,* die von einem Zielcomputer implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="6d115-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="6d115-129">Bei der Kompilierung wird jeder Vorgang als .NET-Klassentyp dargestellt, der den Ziel Computern bereitgestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6d115-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="6d115-130">Im Gegensatz zu Vorgängen werden Funktionen verwendet, um rein klassisches Verhalten zu beschreiben, und Sie haben keine Auswirkungen, außer wenn Sie klassische Ausgabewerte berechnen.</span><span class="sxs-lookup"><span data-stu-id="6d115-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="6d115-131">F # ist eine stark typisierte Sprache und enthält eine Reihe integrierter primitiver Typen sowie Unterstützung für benutzerdefinierte Typen.</span><span class="sxs-lookup"><span data-stu-id="6d115-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="6d115-132">Im weiteren Verlauf dieses Handbuchs erfahren Sie, wie Sie verschiedene sprach Konzepte und-Konstrukte verwenden, um uns bei der Definition komplexer Quantum-Programme über die grundlegenden Bausteine von Vorgängen, Funktionen und Typen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="6d115-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="6d115-133">Struktur von f #-Quelldateien</span><span class="sxs-lookup"><span data-stu-id="6d115-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="6d115-134">Eine Q #-Quelldatei besteht minimal aus einer *Namespace Deklaration*, die einen .NET-Namespace angibt, der die Definitionen in der Quelldatei enthält.</span><span class="sxs-lookup"><span data-stu-id="6d115-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="6d115-135">Definitionen aus anderen Q #-Quelldateien und-Bibliotheken können mithilfe der `open`-Anweisung eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="6d115-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="6d115-136">Beispielsweise werden die meisten Vorgänge, die grundlegende Gates definieren, im <xref:microsoft.quantum.intrinsic>-Namespace definiert.</span><span class="sxs-lookup"><span data-stu-id="6d115-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="6d115-137">Um dies für den Code verfügbar zu machen, `open` Sie einfach den Namespace am Anfang jeder Datei:</span><span class="sxs-lookup"><span data-stu-id="6d115-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="6d115-138">Innerhalb eines Namespace kann jede f #-Quelldatei eine beliebige Kombination von *Vorgängen*, *Funktionen*und *benutzerdefinierten Typen*definieren.</span><span class="sxs-lookup"><span data-stu-id="6d115-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="6d115-139">Im restlichen Teil dieses Abschnitts werden diese wiederum beschrieben und Beispiele dafür bereitgestellt, wie Sie in der Praxis verwendet werden können, um nützliche Quantum-Programme zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6d115-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
