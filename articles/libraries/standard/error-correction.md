---
title: 'Fehlerkorrektur in den Q # Standard-Bibliotheken'
description: 'Erfahren Sie, wie Sie Fehler Behebungs Codes in ihren Q #-Programmen verwenden, während Sie den Zustand der Qubits schützen.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 514fe68f603b9a3a0b4607390719b08a43fe4967
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907765"
---
# <a name="error-correction"></a><span data-ttu-id="0adf9-103">Fehlerkorrektur</span><span class="sxs-lookup"><span data-stu-id="0adf9-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="0adf9-104">Einführung</span><span class="sxs-lookup"><span data-stu-id="0adf9-104">Introduction</span></span> ##

<span data-ttu-id="0adf9-105">Wenn beim klassischen Computing ein wenig vor Fehlern geschützt werden soll, kann es häufig ausreichen, das Bit durch Wiederholen des Daten Bits durch ein *logisches Bit* darzustellen.</span><span class="sxs-lookup"><span data-stu-id="0adf9-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="0adf9-106">Nehmen wir beispielsweise an, dass $ \overline{0} = $0 die Codierung des Datentyps 0 ist. dabei wird die Zeile oberhalb der Bezeichnung 0 verwendet, um anzugeben, dass es sich um eine Codierung eines Bits im Zustand 0 handelt.</span><span class="sxs-lookup"><span data-stu-id="0adf9-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="0adf9-107">Wenn auf ähnliche Weise $ \overline{1} = $111 angezeigt wird, verfügen wir über einen einfachen Wiederholungs Code, der vor einem Bit-Flip-Fehler schützt.</span><span class="sxs-lookup"><span data-stu-id="0adf9-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="0adf9-108">Das heißt, wenn eine der drei Bits gekippt wird, können wir den Zustand des logischen Bits wiederherstellen, indem wir eine Mehrheits Stimme treffen.</span><span class="sxs-lookup"><span data-stu-id="0adf9-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="0adf9-109">Obwohl die klassische Fehlerkorrektur in diesem speziellen Beispiel ein viel reicheres Thema ist (Wir empfehlen die [Einführung in die Codierungstheorie von Lint](https://www.springer.com/us/book/9783540641339)), zeigt der obige Wiederholungs Code bereits auf ein mögliches Problem beim Schutz von Quantum-Informationen.</span><span class="sxs-lookup"><span data-stu-id="0adf9-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="0adf9-110">Das [No-Klon-Theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) impliziert, dass bei der Messung der einzelnen Qubit-Werte und der Stimme der Mehrheit des obigen klassischen Codes die genauen Informationen, die wir zu schützen versuchen, verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="0adf9-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="0adf9-111">In der Quantum-Einstellung werden wir sehen, dass die Messung problematisch ist.</span><span class="sxs-lookup"><span data-stu-id="0adf9-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="0adf9-112">Wir können weiterhin die oben beschriebene Codierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="0adf9-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="0adf9-113">Dies ist hilfreich, um zu sehen, wie die Fehlerkorrektur in den Quantum-Fall generalisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="0adf9-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="0adf9-114">Geben Sie daher $ \ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$ ein, und lassen Sie $ \ket{\overline{1}} = \ket{111}$.</span><span class="sxs-lookup"><span data-stu-id="0adf9-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="0adf9-115">Anschließend haben wir in Linearität unseren Wiederholungs Code für alle Eingaben definiert. Beispiel: $ \ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}})/\sqrt{2} = (\ket{000} + \ket{111})/\sqrt{2}$.</span><span class="sxs-lookup"><span data-stu-id="0adf9-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="0adf9-116">Insbesondere, wenn Sie einen Bit-Flip-Fehler $X _1 $ Act für das mittlere Qubit, sehen wir, dass die Korrektur, die für beide branches erforderlich ist, genau $X _1 $: $ $ \begin{align} x_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left (x_1 \ket{000} + x_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left (\ket{010} + \ket{101} \right).</span><span class="sxs-lookup"><span data-stu-id="0adf9-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="0adf9-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="0adf9-117">\end{align} $$</span></span>

<span data-ttu-id="0adf9-118">Um zu sehen, wie wir erkennen können, dass dies der Fall ist, ohne den Zustand zu messen, den wir zu schützen versuchen, ist es hilfreich, die einzelnen anderen Bits-Flip-Fehler in die logischen Zustände zu schreiben:</span><span class="sxs-lookup"><span data-stu-id="0adf9-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="0adf9-119">Fehler $E $</span><span class="sxs-lookup"><span data-stu-id="0adf9-119">Error $E$</span></span> | <span data-ttu-id="0adf9-120">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="0adf9-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="0adf9-121">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="0adf9-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="0adf9-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="0adf9-122">$\boldone$</span></span> | <span data-ttu-id="0adf9-123">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-123">$\ket{000}$</span></span> | <span data-ttu-id="0adf9-124">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-124">$\ket{111}$</span></span> |
| <span data-ttu-id="0adf9-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-125">$X_0$</span></span> | <span data-ttu-id="0adf9-126">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-126">$\ket{100}$</span></span> | <span data-ttu-id="0adf9-127">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-127">$\ket{011}$</span></span> |
| <span data-ttu-id="0adf9-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-128">$X_1$</span></span> | <span data-ttu-id="0adf9-129">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-129">$\ket{010}$</span></span> | <span data-ttu-id="0adf9-130">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-130">$\ket{101}$</span></span> |
| <span data-ttu-id="0adf9-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-131">$X_2$</span></span> | <span data-ttu-id="0adf9-132">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-132">$\ket{001}$</span></span> | <span data-ttu-id="0adf9-133">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-133">$\ket{110}$</span></span> |

<span data-ttu-id="0adf9-134">Um den Zustand zu schützen, den wir codieren, müssen wir die drei Fehler voneinander und von der Identität $ \boldone $ unterscheiden können, ohne zwischen "$ \ket{\overline{0}} $" und "$ \ket{\overline{1}} $" zu unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="0adf9-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="0adf9-135">Wenn z. b. $Z _0 $ gemessen wird, erhalten wir ein anderes Ergebnis für "$ \ket{\overline{0}} $" und "$ \ket{\overline{1}} $" im Fehlerfall, sodass der codierte Zustand reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="0adf9-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="0adf9-136">Auf der anderen Seite können Sie $Z _0 Z_1 $ Messen, die Parität der ersten beiden Bits in den einzelnen Berechnungs Status Zuständen.</span><span class="sxs-lookup"><span data-stu-id="0adf9-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="0adf9-137">Beachten Sie, dass jede Messung eines Pauli-Operators überprüft, welcher eigen Wert der gemessene Wert entspricht. Daher können wir für jeden Status $ \ket{\psi} $ in der obigen Tabelle $Z _0-Z_1 \ket{\psi} $ berechnen, um festzustellen, ob "$ \pm\ket{\psi} $" erhalten wird.</span><span class="sxs-lookup"><span data-stu-id="0adf9-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="0adf9-138">Beachten Sie, dass $Z _0 Z_1 \ket{000} = \ket{000}$ und diese $Z _0 Z_1 \ket{111} = \ket{111}$, sodass wir feststellen, dass diese Maßeinheit den beiden codierten Zuständen dasselbe entspricht.</span><span class="sxs-lookup"><span data-stu-id="0adf9-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="0adf9-139">Auf der anderen Seite $Z _0 Z_1 \ket{100} =-\ket{100}$ und $Z _0 Z_1 \ket{011} =-\ket{011}$. das Ergebnis der Messung $Z _0 $ zeigt daher nützliche Informationen über den Fehler an.</span><span class="sxs-lookup"><span data-stu-id="0adf9-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="0adf9-140">Um dies hervorzuheben, wiederholen wir die obige Tabelle, fügen jedoch die Ergebnisse der Messung $Z _0 Z_1 $ und $Z _1 Z_2 $ für jede Zeile hinzu.</span><span class="sxs-lookup"><span data-stu-id="0adf9-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="0adf9-141">Wir bezeichnen die Ergebnisse der einzelnen Messungen durch das Vorzeichen des Eigenwerts, der beobachtet wird, entweder $ + $ oder $-$, der den Q #-`Result` Werten von `Zero` bzw. der `One`entspricht.</span><span class="sxs-lookup"><span data-stu-id="0adf9-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="0adf9-142">Fehler $E $</span><span class="sxs-lookup"><span data-stu-id="0adf9-142">Error $E$</span></span> | <span data-ttu-id="0adf9-143">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="0adf9-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="0adf9-144">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="0adf9-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="0adf9-145">Ergebnis der $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="0adf9-146">Ergebnis der $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="0adf9-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="0adf9-147">$\boldone$</span></span> | <span data-ttu-id="0adf9-148">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-148">$\ket{000}$</span></span> | <span data-ttu-id="0adf9-149">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="0adf9-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-150">$X_0$</span></span> | <span data-ttu-id="0adf9-151">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-151">$\ket{100}$</span></span> | <span data-ttu-id="0adf9-152">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="0adf9-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-153">$X_1$</span></span> | <span data-ttu-id="0adf9-154">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-154">$\ket{010}$</span></span> | <span data-ttu-id="0adf9-155">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="0adf9-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="0adf9-156">$X_2$</span></span> | <span data-ttu-id="0adf9-157">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-157">$\ket{001}$</span></span> | <span data-ttu-id="0adf9-158">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="0adf9-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="0adf9-159">Folglich wird durch die Ergebnisse der beiden Messungen eindeutig festgelegt, welcher bitflip-Fehler aufgetreten ist, ohne dass Informationen zu dem von uns codierten Zustand offengelegt werden.</span><span class="sxs-lookup"><span data-stu-id="0adf9-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="0adf9-160">Wir bezeichnen diese Ergebnisse als ein- *Syndrom*und verweisen auf den Prozess der Zuordnung eines-Syndroms zu dem Fehler, der die wieder *Herstellung*verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="0adf9-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="0adf9-161">Insbesondere betonen wir, dass die Wiederherstellung eine *klassische* Inferenz ist, die als Eingabe das betreffende-Syndrom übernimmt und eine Korrektur für die Behebung von Fehlern zurückgibt, die möglicherweise aufgetreten sind.</span><span class="sxs-lookup"><span data-stu-id="0adf9-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="0adf9-162">Der obige bitflip-Code kann nur mit einzelnen Bit-Flip-Fehlern korrigiert werden. Das heißt, ein `X` Vorgang, der auf einem einzelnen Qubit agiert.</span><span class="sxs-lookup"><span data-stu-id="0adf9-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="0adf9-163">Wenn Sie `X` auf mehr als ein Qubit anwenden, wird "$ \ket{\overline{0}} $" auf "$ \ket{\overline{1}} $" nach der Wiederherstellung zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="0adf9-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="0adf9-164">Auf ähnliche Weise wird durch das Anwenden eines Phasen kippen `Z` $ \ket{\overline{1}} $ zu $-\ket{\overline{1}} $ zugeordnet. Daher wird $ \ket{\overline{+}} $ zu $ \ket{\overline{-}} $ zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="0adf9-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="0adf9-165">Im Allgemeinen können Codes erstellt werden, um eine größere Anzahl von Fehlern zu verarbeiten und $Z $ Errors sowie $X $ Errors zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="0adf9-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="0adf9-166">Die Erkenntnis, dass wir Messungen in der Quantum-Fehlerkorrektur beschreiben können, die auf die gleiche Weise für alle Code Zustände agieren, ist der Grund für die *stabilisatformalität*.</span><span class="sxs-lookup"><span data-stu-id="0adf9-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="0adf9-167">Q # Canon bietet ein Framework zum Beschreiben der Codierung in und Decodierung von Stabilisator-Codes und zum Beschreiben der Art und Weise, wie eine von Fehlern wieder hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="0adf9-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="0adf9-168">In diesem Abschnitt werden dieses Framework und seine Anwendung für einige einfache Quantum-Fehler Behebungs Codes beschrieben.</span><span class="sxs-lookup"><span data-stu-id="0adf9-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="0adf9-169">Eine vollständige Einführung in die Stabilisator-Formalität geht über den Rahmen dieses Abschnitts hinaus.</span><span class="sxs-lookup"><span data-stu-id="0adf9-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="0adf9-170">Wir freuen uns auf Leser, die mehr über den [Mann 2009](https://arxiv.org/abs/0904.2557)lernen möchten.</span><span class="sxs-lookup"><span data-stu-id="0adf9-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-q"></a><span data-ttu-id="0adf9-171">Darstellen von Fehler Behebungs Codes in f #</span><span class="sxs-lookup"><span data-stu-id="0adf9-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="0adf9-172">Zur Unterstützung der Angabe von Fehler Behebungs Codes bietet Q # Canon mehrere verschiedene benutzerdefinierte Typen:</span><span class="sxs-lookup"><span data-stu-id="0adf9-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="0adf9-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: gibt an, dass ein Register von Qubits als Codeblock eines Fehler Behebungs Codes interpretiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="0adf9-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="0adf9-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: gibt an, dass ein Array von Messergebnissen als das auf einem Codeblock gemessene Syndrom interpretiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="0adf9-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="0adf9-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: gibt an, dass eine *klassische* Funktion verwendet werden soll, um ein-Syndrom zu interpretieren und eine Korrektur zurückzugeben, die angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="0adf9-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="0adf9-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: gibt an, dass ein Vorgang Qubits zum Darstellen von Daten zusammen mit neuen Ancilla-Qubits annimmt, um einen Codeblock eines Fehler Behebungs Codes zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="0adf9-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="0adf9-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: bezeichnet, als ein Vorgang einen Codeblock eines Fehlers korrigiert, der den Code in die Daten-Qubits korrigiert, und die für die Darstellung von-Tool Informationen verwendeten Ancilla-Qubits.</span><span class="sxs-lookup"><span data-stu-id="0adf9-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="0adf9-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: bezeichnet einen Vorgang, der zum Extrahieren von Informationen aus einem Codeblock verwendet werden soll, ohne dass der durch den Code geschützte Zustand gestört wird.</span><span class="sxs-lookup"><span data-stu-id="0adf9-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="0adf9-179">Schließlich stellt der Kanon den <xref:microsoft.quantum.errorcorrection.qecc> Typ bereit, um die anderen Typen zu erfassen, die zum Definieren eines Quantum-Fehler Behebungs Codes erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="0adf9-179">Finally, the canon provides the <xref:microsoft.quantum.errorcorrection.qecc> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="0adf9-180">Jedem Stabilisator-quantencode ist die Codelänge $n $, die Anzahl $k $ logischer Qubits und die minimale Entfernung $d $ zugeordnet, die häufig in der Notation ⟦ $n $, $k $, $d $ ⟧ gruppiert sind.</span><span class="sxs-lookup"><span data-stu-id="0adf9-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="0adf9-181">Die <xref:microsoft.quantum.errorcorrection.bitflipcode>-Funktion definiert z. b. den ⟦ 3, 1, 1 ⟧ Bit-Flip-Code:</span><span class="sxs-lookup"><span data-stu-id="0adf9-181">For example, the <xref:microsoft.quantum.errorcorrection.bitflipcode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="0adf9-182">Beachten Sie, dass der `QECC` Typ *keine* Wiederherstellungs Funktion enthält.</span><span class="sxs-lookup"><span data-stu-id="0adf9-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="0adf9-183">Dies ermöglicht es uns, die Wiederherstellungs Funktion zu ändern, die bei der Behebung von Fehlern verwendet wird, ohne die Definition des Codes selbst zu ändern. Diese Möglichkeit ist besonders nützlich, wenn Sie Feedback von Charakterisierungs Messungen in das Modell integrieren, das von der Wiederherstellung angenommen wird.</span><span class="sxs-lookup"><span data-stu-id="0adf9-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="0adf9-184">Nachdem ein Code auf diese Weise definiert wurde, können wir den <xref:microsoft.quantum.errorcorrection.recover>-Vorgang verwenden, um nach Fehlern wiederherzustellen:</span><span class="sxs-lookup"><span data-stu-id="0adf9-184">Once a code is defined in this way, we can use the <xref:microsoft.quantum.errorcorrection.recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="0adf9-185">Wir untersuchen dies im [bitflip-Codebeispiel](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code)ausführlicher.</span><span class="sxs-lookup"><span data-stu-id="0adf9-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="0adf9-186">Abgesehen vom Bit-Flip-Code wird der Q #-Kanon mit Implementierungen des [perfekten 5-Qubit-Codes](https://arxiv.org/abs/quant-ph/9602019)bereitgestellt, und der [sieben-Qubit](https://arxiv.org/abs/quant-ph/9705052)-Code, der beide einen beliebigen Single-Qubit-Fehler beheben kann.</span><span class="sxs-lookup"><span data-stu-id="0adf9-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
