---
title: Intrinsische Vorgänge und Funktionen im QDK
description: Erfahren Sie mehr über die intrinsischen Vorgänge und Funktionen im QDK, einschließlich klassischer Funktionen und einheitlicher, Rotations-und maßoperationen.
author: QuantumWriter
uid: microsoft.quantum.libraries.standard.prelude
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: b1c26c632f36b6c254d940a89b13638f7592ab80
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907204"
---
# <a name="the-prelude"></a><span data-ttu-id="5f11b-103">Der Auftakt</span><span class="sxs-lookup"><span data-stu-id="5f11b-103">The Prelude</span></span> #

<span data-ttu-id="5f11b-104">Der f #-Compiler und die im Quantum Development Kit enthaltenen Zielcomputer stellen eine Reihe von intrinsischen Funktionen und Vorgängen bereit, die beim Schreiben von Quantum-Programmen in Q # verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="5f11b-104">The Q# compiler and the target machines included with the Quantum Development Kit provide a set of intrinsic functions and operations that can be used when writing quantum programs in Q#.</span></span>

## <a name="intrinsic-operations-and-functions"></a><span data-ttu-id="5f11b-105">Intrinsische Vorgänge und Funktionen</span><span class="sxs-lookup"><span data-stu-id="5f11b-105">Intrinsic Operations and Functions</span></span> ##

<span data-ttu-id="5f11b-106">Die in der Standardbibliothek definierten systeminternen Vorgänge sind in einer von mehreren Kategorien unterteilt:</span><span class="sxs-lookup"><span data-stu-id="5f11b-106">The intrinsic operations defined in the standard library roughly fall into one of several categories:</span></span>

- <span data-ttu-id="5f11b-107">Wichtige klassische Funktionen, die im <xref:microsoft.quantum.core>-Namespace gesammelt werden.</span><span class="sxs-lookup"><span data-stu-id="5f11b-107">Essential classical functions, collected in the <xref:microsoft.quantum.core> namespace.</span></span>
- <span data-ttu-id="5f11b-108">Vorgänge, die die von [Clifford und $T $ Gates erstellten unitoren](xref:microsoft.quantum.concepts.qubit)darstellen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-108">Operations representing unitaries composed of [Clifford and $T$ gates](xref:microsoft.quantum.concepts.qubit).</span></span>
- <span data-ttu-id="5f11b-109">Vorgänge, die Drehungen zu verschiedenen Operatoren darstellen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-109">Operations representing rotations about various operators.</span></span>
- <span data-ttu-id="5f11b-110">Vorgänge zum Implementieren von Messungen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-110">Operations implementing measurements.</span></span>

<span data-ttu-id="5f11b-111">Da der Clifford + $T $ Gate-Satz für das Quantum Computing [universell](xref:microsoft.quantum.concepts.multiple-qubits) ist, reichen diese Vorgänge aus, um einen beliebigen Quantum-Algorithmus innerhalb eines negisch kleinen Fehlers zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="5f11b-111">Since the Clifford + $T$ gate set is [universal](xref:microsoft.quantum.concepts.multiple-qubits) for quantum computing, these operations suffice to approximately implement any quantum algorithm within negligibly small error.</span></span>
<span data-ttu-id="5f11b-112">Durch die Bereitstellung von Rotationen ermöglicht Q # dem Programmierer, in der einzelnen Qubit-Bibliothek mit einheitlicher und CNOT Gate zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="5f11b-112">By providing rotations as well, Q# allows the programmer to work within the single qubit unitary and CNOT gate library.</span></span> <span data-ttu-id="5f11b-113">Diese Bibliothek ist viel leichter zu überprüfen, da der Programmierer keinen direkten Ausdruck der Clifford + $T $-Zerlegung erfordert, und da für die Kompilierung einzelner Qubit-unitoren in Clifford und $T $ Gates sehr effiziente Methoden vorhanden sind (Weitere Informationen finden Sie [hier](xref:microsoft.quantum.more-information) ).</span><span class="sxs-lookup"><span data-stu-id="5f11b-113">This library is much easier to think about because it does not  require the programmer to directly express the Clifford + $T$ decomposition and because highly efficient methods exist for compiling single qubit unitaries into Clifford and $T$ gates (see [here](xref:microsoft.quantum.more-information) for more information).</span></span>

<span data-ttu-id="5f11b-114">Wenn möglich ermöglichen die in der Einleitung definierten Vorgänge, die auf Qubits reagieren, das Anwenden des `Controlled` Variant, sodass der Zielcomputer die geeignete Zerlegung ausführt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-114">Where possible, the operations defined in the prelude which act on qubits allow for applying the `Controlled` variant, such that the target machine will perform the appropriate decomposition.</span></span>

<span data-ttu-id="5f11b-115">Viele der in diesem Teil der Einleitung definierten Funktionen und Vorgänge befinden sich im @"microsoft.quantum.intrinsic"-Namespace, sodass die meisten Q #-Quelldateien über eine `open Microsoft.Quantum.Intrinsic;` Direktive verfügen, die direkt auf die anfängliche Namespace Deklaration folgt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-115">Many of the functions and operations defined in this portion of the prelude are in the @"microsoft.quantum.intrinsic" namespace, such that most Q# source files will have an `open Microsoft.Quantum.Intrinsic;` directive immediately following the initial namespace declaration.</span></span>
<span data-ttu-id="5f11b-116">Der <xref:microsoft.quantum.core>-Namespace wird automatisch geöffnet, sodass Funktionen wie <xref:microsoft.quantum.core.length> ohne eine `open`-Anweisung verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="5f11b-116">The <xref:microsoft.quantum.core> namespace is automatically opened, so that functions such as <xref:microsoft.quantum.core.length> can be used without an `open` statement at all.</span></span>

### <a name="common-single-qubit-unitary-operations"></a><span data-ttu-id="5f11b-117">Allgemeine Single-Qubit-einheitliche Vorgänge</span><span class="sxs-lookup"><span data-stu-id="5f11b-117">Common Single-Qubit Unitary Operations</span></span> ###

<span data-ttu-id="5f11b-118">Der-Auftakt definiert außerdem viele gängige [Single-Qubit-Vorgänge](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span><span class="sxs-lookup"><span data-stu-id="5f11b-118">The prelude also defines many common [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span></span>
<span data-ttu-id="5f11b-119">Alle diese Vorgänge ermöglichen sowohl das `Controlled`-als auch das `Adjoint`-funktors.</span><span class="sxs-lookup"><span data-stu-id="5f11b-119">All of these operations allow both the `Controlled` and `Adjoint` functors.</span></span>

#### <a name="pauli-operators"></a><span data-ttu-id="5f11b-120">Pauli-Operatoren</span><span class="sxs-lookup"><span data-stu-id="5f11b-120">Pauli Operators</span></span> ####

<span data-ttu-id="5f11b-121">Der <xref:microsoft.quantum.intrinsic.x> Vorgang implementiert den "Pauli $X $"-Operator.</span><span class="sxs-lookup"><span data-stu-id="5f11b-121">The <xref:microsoft.quantum.intrinsic.x> operation implements the Pauli $X$ operator.</span></span>
<span data-ttu-id="5f11b-122">Dies wird manchmal auch als `NOT` Gate bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-122">This is sometimes also known as the `NOT` gate.</span></span>
<span data-ttu-id="5f11b-123">Sie verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-123">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-124">Dies entspricht der einheitlichen Single-Qubit-Version:</span><span class="sxs-lookup"><span data-stu-id="5f11b-124">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="5f11b-125">\begin{Equation} \begin{bmatrix} 0 & 1 \\\\% FIXME: aktuell wird der quadwhack-Hack verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-125">\begin{equation} \begin{bmatrix} 0 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="5f11b-126">1 & 0 \ End{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="5f11b-126">1 & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="5f11b-127">Der <xref:microsoft.quantum.intrinsic.y> Vorgang implementiert den "Pauli $Y $"-Operator.</span><span class="sxs-lookup"><span data-stu-id="5f11b-127">The <xref:microsoft.quantum.intrinsic.y> operation implements the Pauli $Y$ operator.</span></span>
<span data-ttu-id="5f11b-128">Sie verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-128">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-129">Dies entspricht der einheitlichen Single-Qubit-Version:</span><span class="sxs-lookup"><span data-stu-id="5f11b-129">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="5f11b-130">\begin{Equation} \begin{bmatrix} 0 &-i \\\\% FIXME: aktuell wird der quadwhack-Hack verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-130">\begin{equation} \begin{bmatrix} 0 & -i \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="5f11b-131">i & 0 \ End{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="5f11b-131">i & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="5f11b-132">Der <xref:microsoft.quantum.intrinsic.z> Vorgang implementiert den "Pauli $Z $"-Operator.</span><span class="sxs-lookup"><span data-stu-id="5f11b-132">The <xref:microsoft.quantum.intrinsic.z> operation implements the Pauli $Z$ operator.</span></span>
<span data-ttu-id="5f11b-133">Sie verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-133">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-134">Dies entspricht der einheitlichen Single-Qubit-Version:</span><span class="sxs-lookup"><span data-stu-id="5f11b-134">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="5f11b-135">\begin{Equation} \begin{bmatrix} 1 & 0 \\\\% FIXME: aktuell wird der quadwhack-Hack verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-135">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="5f11b-136">0 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="5f11b-136">0 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="5f11b-137">Unten sehen Sie, dass diese Transformationen der [Bloch-Kugel](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) zugeordnet sind (die Drehungs Achse in jedem Fall wird rot hervorgehoben):</span><span class="sxs-lookup"><span data-stu-id="5f11b-137">Below we see these transformations mapped to the [Bloch sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (the rotation axis in each case is highlighted red):</span></span>

![Auf der Bloch-Kugel zugeordnete Pauli-Vorgänge](~/media/prelude_pauliBloch.png)

<span data-ttu-id="5f11b-139">Es ist wichtig zu beachten, dass durch das doppelte Anwenden desselben Pauli-Tors auf das gleiche Qubit der Vorgang abgebrochen wird (da Sie nun eine vollständige Rotation von 2 (360 °) über der Oberfläche bis zur Bloch-Kugel durchgeführt haben und somit am Ausgangspunkt zurückkehren.</span><span class="sxs-lookup"><span data-stu-id="5f11b-139">It is important to note that applying the same Pauli gate twice to the same qubit cancels out the operation (because you have now performed a full rotation of 2π (360°) over the surface to the Bloch Sphere, thus arriving back at the starting point).</span></span> <span data-ttu-id="5f11b-140">Dies bringt uns zur folgenden Identität:</span><span class="sxs-lookup"><span data-stu-id="5f11b-140">This brings us to the following identity:</span></span>

<span data-ttu-id="5f11b-141">$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \boldone $ $</span><span class="sxs-lookup"><span data-stu-id="5f11b-141">$$ X^2=Y^2=Z^2=\boldone $$</span></span>

<span data-ttu-id="5f11b-142">Dies kann auf der Bloch-Kugel visualisiert werden:</span><span class="sxs-lookup"><span data-stu-id="5f11b-142">This can be visualised on the Bloch sphere:</span></span>

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a><span data-ttu-id="5f11b-144">Andere einzelqubit Clif-Fords</span><span class="sxs-lookup"><span data-stu-id="5f11b-144">Other Single-Qubit Cliffords</span></span> ####

<span data-ttu-id="5f11b-145">Der <xref:microsoft.quantum.intrinsic.h> Vorgang implementiert das Hadamard-Gate.</span><span class="sxs-lookup"><span data-stu-id="5f11b-145">The <xref:microsoft.quantum.intrinsic.h> operation implements the Hadamard gate.</span></span>
<span data-ttu-id="5f11b-146">Dadurch wird die Pauli-$X $ und $Z $-Achse des Ziel-Qubit geändert, sodass $H \ket{0} = \ket{+} \mathrel{: =} (\ket{0} + \ket{1})/\sqrt{2}$ und $H \ket{+} = \ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="5f11b-146">This interchanges the Pauli $X$ and $Z$ axes of the target qubit, such that $H\ket{0} = \ket{+} \mathrel{:=} (\ket{0} + \ket{1}) / \sqrt{2}$ and $H\ket{+} = \ket{0}$.</span></span>
<span data-ttu-id="5f11b-147">Sie verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`und entspricht der einheitlichen Single-Qubit:</span><span class="sxs-lookup"><span data-stu-id="5f11b-147">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="5f11b-148">\begin{Equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\% FIXME: aktuell wird der quadwhack-Hack verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-148">\begin{equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="5f11b-149">1 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="5f11b-149">1 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="5f11b-150">Das Hadamard-Gate ist besonders wichtig, da es verwendet werden kann, um eine übergeordnete Position von $ \ket{0}$ und $ \ket{1}$ States zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-150">The Hadamard gate is particularly important as it can be used to create a superposition of the $\ket{0}$ and $\ket{1}$ states.</span></span> <span data-ttu-id="5f11b-151">In der Bloch Sphere-Darstellung ist es am einfachsten, dies als Drehung von $ \ket{\psi} $ um die x-Achse um $ \pi $ radiane ($ 180 ^ \circ $), gefolgt von einer (im Uhrzeigersinn) Drehung um die y-Achse durch $ \ Pi/2 $ radiane ($ 90 ^ \circ $)</span><span class="sxs-lookup"><span data-stu-id="5f11b-151">In the Bloch sphere representation, it is easiest to think of this as a rotation of $\ket{\psi}$ around the x-axis by $\pi$ radians ($180^\circ$) followed by a (clockwise) rotation around the y-axis by $\pi/2$ radians ($90^\circ$):</span></span>

![Hadamard-Vorgang auf der Bloch-Kugel zugeordnet](~/media/prelude_hadamardBloch.png)

<span data-ttu-id="5f11b-153">Der <xref:microsoft.quantum.intrinsic.s> Vorgang implementiert das-Phasen Gate $S $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-153">The <xref:microsoft.quantum.intrinsic.s> operation implements the phase gate $S$.</span></span>
<span data-ttu-id="5f11b-154">Dies ist die Quadratwurzel der Matrix des Pauli-$Z $-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="5f11b-154">This is the matrix square root of the Pauli $Z$ operation.</span></span>
<span data-ttu-id="5f11b-155">Das heißt, $S ^ 2 = Z $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-155">That is, $S^2 = Z$.</span></span>
<span data-ttu-id="5f11b-156">Sie verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`und entspricht der einheitlichen Single-Qubit:</span><span class="sxs-lookup"><span data-stu-id="5f11b-156">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="5f11b-157">\begin{Equation} \begin{bmatrix} 1 & 0 \\\\% FIXME: aktuell wird der quadwhack-Hack verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-157">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="5f11b-158">0 & i \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="5f11b-158">0 & i \end{bmatrix} \end{equation}</span></span>

#### <a name="rotations"></a><span data-ttu-id="5f11b-159">Drehungen</span><span class="sxs-lookup"><span data-stu-id="5f11b-159">Rotations</span></span> ####

<span data-ttu-id="5f11b-160">Zusätzlich zu den oben beschriebenen Pauli-und Clifford-Vorgängen bietet Q # Prelude eine Vielzahl von Möglichkeiten, um Drehungen auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="5f11b-160">In addition to the Pauli and Clifford operations above, the Q# prelude provides a variety of ways of expressing rotations.</span></span>
<span data-ttu-id="5f11b-161">Wie in [Single-Qubit-Vorgängen](xref:microsoft.quantum.concepts.qubit#single-qubit-operations)beschrieben, ist die Möglichkeit der Rotation für Quantum-Algorithmen von entscheidender Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="5f11b-161">As described in [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), the ability to rotate is critical to quantum algorithms.</span></span>

<span data-ttu-id="5f11b-162">Wir gehen zunächst von der Erinnerung aus, dass wir jeden einzelnen Qubit-Vorgang mithilfe der $H $ und $T $ Gates Ausdrücken können. dabei ist $H $ der Hadamard-Vorgang und WHERE \begin{Equation} T \mathrel{: =} \begin{bmatrix} 1 & 0 \\\\% FIXME: Dies verwendet derzeit den Quad Back zerstören</span><span class="sxs-lookup"><span data-stu-id="5f11b-162">We start by recalling that we can express any single-qubit operation using the $H$ and $T$ gates, where $H$ is the Hadamard operation, and where \begin{equation} T \mathrel{:=} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quad back whack hack.</span></span>
<span data-ttu-id="5f11b-163">0 & e ^ {i \pi/4} \end{bmatrix} \end{Equation} Dies ist die Quadratwurzel des <xref:microsoft.quantum.intrinsic.s> Vorgangs, d. h. $T ^ 2 = S $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-163">0 & e^{i \pi / 4} \end{bmatrix} \end{equation} This is the square root of the <xref:microsoft.quantum.intrinsic.s> operation, such that $T^2 = S$.</span></span>
<span data-ttu-id="5f11b-164">Die $T $ Gate wird wiederum vom <xref:microsoft.quantum.intrinsic.t>-Vorgang implementiert und verfügt über eine Signatur `(Qubit => Unit is Adj + Ctl)`, die angibt, dass es sich um einen einheitlichen Vorgang auf einem Single-Qubit handelt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-164">The $T$ gate is in turn implemented by the <xref:microsoft.quantum.intrinsic.t> operation, and has signature `(Qubit => Unit is Adj + Ctl)`, indicating that it is a unitary operation on a single-qubit.</span></span>

<span data-ttu-id="5f11b-165">Obwohl dies im Prinzip ausreichend ist, um einen beliebigen Single-Qubit-Vorgang zu beschreiben, haben unterschiedliche Zielcomputer möglicherweise effizientere Darstellungen für Rotationen von Pauli-Operatoren, sodass die Zusammenführung eine Vielzahl von Methoden für die Arbeit enthält. Diese Rotationen werden ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-165">Even though this is in principle sufficient to describe any arbitrary single-qubit operation, different target machines may have more efficient representations for rotations about Pauli operators, such that the prelude includes a variety of ways to convienently express such rotations.</span></span>
<span data-ttu-id="5f11b-166">Die grundlegendste davon ist der <xref:microsoft.quantum.intrinsic.r> Vorgang, der eine Drehung um eine angegebene Pauli-Achse implementiert. \begin{Equation} R (\sigma, \phi) \mathrel{: =} \exp (-i \phi \sigma/2), \end{Equation}, wobei $ \sigma $ ein Pauli-Operator ist, $ \phi $ ein Winkel ist und $ \exp $ den exponentiellen Wert der Matrix darstellt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-166">The most basic of these is the <xref:microsoft.quantum.intrinsic.r> operation, which implements a rotation around a specified Pauli axis, \begin{equation} R(\sigma, \phi) \mathrel{:=} \exp(-i \phi \sigma / 2), \end{equation} where $\sigma$ is a Pauli operator, $\phi$ is an angle, and where $\exp$ represents the matrix exponential.</span></span>
<span data-ttu-id="5f11b-167">Es verfügt über eine Signatur `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, wobei die ersten beiden Teile der Eingabe die klassischen Argumente $ \sigma $ und $ \phi $ darstellen, um den einheitlichen Operator $R (\sigma, \phi) $ anzugeben.</span><span class="sxs-lookup"><span data-stu-id="5f11b-167">It has signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, where the first two parts of the input represent the classical arguments $\sigma$ and $\phi$ needed to specify the unitary operator $R(\sigma, \phi)$.</span></span>
<span data-ttu-id="5f11b-168">Wir können $ \sigma $ und $ \phi $ teilweise anwenden, um einen Vorgang zu erhalten, dessen Typ mit einer Single-Qubit-einheitlich ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-168">We can partially apply $\sigma$ and $\phi$ to obtain an operation whose type is that of a single-qubit unitary.</span></span>
<span data-ttu-id="5f11b-169">`R(PauliZ, PI() / 4, _)` hat z. b. den Typ `(Qubit => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-169">For example, `R(PauliZ, PI() / 4, _)` has type `(Qubit => Unit is Adj + Ctl)`.</span></span>

> [!NOTE]
> <span data-ttu-id="5f11b-170">Der <xref:microsoft.quantum.intrinsic.r>-Vorgang dividiert den Eingabe Winkel um 2 und multipliziert ihn mit-1.</span><span class="sxs-lookup"><span data-stu-id="5f11b-170">The <xref:microsoft.quantum.intrinsic.r> operation divides the input angle by 2 and multiplies it by -1.</span></span>
> <span data-ttu-id="5f11b-171">Bei $Z $-Drehungen bedeutet dies, dass der $ \ket-{0}$ eigen State um $-\phi/$2 gedreht wird und der $ \ket-{1}$ eigen State durch $ \phi/$2 gedreht wird, sodass der $ \ket{1}$ eigen State um $ \phi $ in Relation zum $ \ket{0}$ eigen State gedreht wird.</span><span class="sxs-lookup"><span data-stu-id="5f11b-171">For $Z$ rotations, this means that the $\ket{0}$ eigenstate is rotated by $-\phi / 2$ and the $\ket{1}$ eigenstate is rotated by $\phi / 2$, so that the $\ket{1}$ eigenstate is rotated by $\phi$ relative to the $\ket{0}$ eigenstate.</span></span>
>
> <span data-ttu-id="5f11b-172">Dies bedeutet insbesondere, dass sich `T` und `R(PauliZ, PI() / 8, _)` nur durch eine irrelevante [globale Phase](xref:microsoft.quantum.glossary#global-phase)unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="5f11b-172">In particular, this means that `T` and `R(PauliZ, PI() / 8, _)` differ only by an irrelevant [global phase](xref:microsoft.quantum.glossary#global-phase).</span></span>
> <span data-ttu-id="5f11b-173">Aus diesem Grund wird $T $ manchmal als $ \bruchteil {\pi}{8}$-Gate bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-173">For this reason, $T$ is sometimes known as the $\frac{\pi}{8}$-gate.</span></span>
>
> <span data-ttu-id="5f11b-174">Beachten Sie auch, dass beim Drehen um `PauliI` einfach eine globale Phase von $ \phi/$2 angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="5f11b-174">Note also that rotating around `PauliI` simply applies a global phase of $\phi / 2$.</span></span> <span data-ttu-id="5f11b-175">Obwohl solche Phasen irrelevant sind, wie in [den konzeptionellen Dokumenten](xref:microsoft.quantum.concepts.qubit)argumentiert, sind Sie für gesteuerte `PauliI` Drehungen relevant.</span><span class="sxs-lookup"><span data-stu-id="5f11b-175">While such phases are irrelevant, as argued in [the conceptual documents](xref:microsoft.quantum.concepts.qubit), they are relevant for controlled `PauliI` rotations.</span></span>

<span data-ttu-id="5f11b-176">Innerhalb von Quantum-Algorithmen ist es häufig hilfreich, Rotationen als dyadic-Bruchteile auszudrücken, z. b. $ \phi = \pi k/2 ^ n $ für einige $k \in \mathbb{z} $ und $n \in \mathbb{n} $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-176">Within quantum algorithms, it is often useful to express rotations as dyadic fractions, such that $\phi = \pi k / 2^n$ for some $k \in \mathbb{Z}$ and $n \in \mathbb{N}$.</span></span>
<span data-ttu-id="5f11b-177">Der <xref:microsoft.quantum.intrinsic.rfrac> Vorgang implementiert eine Drehung um eine angegebene Pauli-Achse, die diese Konvention verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f11b-177">The <xref:microsoft.quantum.intrinsic.rfrac> operation implements a rotation around a specified Pauli axis using this convention.</span></span>
<span data-ttu-id="5f11b-178">Dies unterscheidet sich von der <xref:microsoft.quantum.intrinsic.r>, dass der Drehungs Winkel als zwei Eingaben vom Typ "`Int`" angegeben wird, die als dyadic-Bruchteil interpretiert werden.</span><span class="sxs-lookup"><span data-stu-id="5f11b-178">It differs from <xref:microsoft.quantum.intrinsic.r> in that the rotation angle is specified as two inputs of type `Int`, interpreted as a dyadic fraction.</span></span>
<span data-ttu-id="5f11b-179">Daher `RFrac` eine Signatur `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-179">Thus, `RFrac` has signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-180">Es implementiert die einheitliche Single-Qubit-$ \exp (i \pi k \sigma/2 ^ n) $, wobei $ \sigma $ die für das erste Argument entsprechende Pauli-Matrix ist, $k $ das zweite Argument und $n $ das dritte Argument ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-180">It implements the single-qubit unitary $\exp(i \pi k \sigma / 2^n)$, where $\sigma$ is the Pauli matrix corresponding to the first argument, $k$ is the second argument, and $n$ is the third argument.</span></span>
<span data-ttu-id="5f11b-181">`RFrac(_,k,n,_)` ist mit `R(_,-πk/2^n,_)`identisch. Beachten Sie, dass der Winkel der *negative* Anteil des Bruchteils ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-181">`RFrac(_,k,n,_)` is the same as `R(_,-πk/2^n,_)`; note that the angle is the *negative* of the fraction.</span></span>

<span data-ttu-id="5f11b-182">Der <xref:microsoft.quantum.intrinsic.rx> Vorgang implementiert eine Drehung um die Pauli $X $-Achse.</span><span class="sxs-lookup"><span data-stu-id="5f11b-182">The <xref:microsoft.quantum.intrinsic.rx> operation implements a rotation around the Pauli $X$ axis.</span></span>
<span data-ttu-id="5f11b-183">Sie verfügt über eine Signatur `((Double, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-183">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-184">`Rx(_, _)` ist identisch mit `R(PauliX, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-184">`Rx(_, _)` is the same as `R(PauliX, _, _)`.</span></span>

<span data-ttu-id="5f11b-185">Der <xref:microsoft.quantum.intrinsic.ry> Vorgang implementiert eine Drehung um die Pauli $Y $-Achse.</span><span class="sxs-lookup"><span data-stu-id="5f11b-185">The <xref:microsoft.quantum.intrinsic.ry> operation implements a rotation around the Pauli $Y$ axis.</span></span>
<span data-ttu-id="5f11b-186">Sie verfügt über eine Signatur `((Double, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-186">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-187">`Ry(_, _)` ist identisch mit `R(PauliY,_ , _)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-187">`Ry(_, _)` is the same as `R(PauliY,_ , _)`.</span></span>

<span data-ttu-id="5f11b-188">Der <xref:microsoft.quantum.intrinsic.rz> Vorgang implementiert eine Drehung um die Pauli $Z $-Achse.</span><span class="sxs-lookup"><span data-stu-id="5f11b-188">The <xref:microsoft.quantum.intrinsic.rz> operation implements a rotation around the Pauli $Z$ axis.</span></span>
<span data-ttu-id="5f11b-189">Sie verfügt über eine Signatur `((Double, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-189">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-190">`Rz(_, _)` ist identisch mit `R(PauliZ, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-190">`Rz(_, _)` is the same as `R(PauliZ, _, _)`.</span></span>

<span data-ttu-id="5f11b-191">Der <xref:microsoft.quantum.intrinsic.r1> Vorgang implementiert eine Drehung um den angegebenen Betrag um $ \ket{1}$, den $-$1-eigen Status von $Z $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-191">The <xref:microsoft.quantum.intrinsic.r1> operation implements a rotation by the given amount around $\ket{1}$, the $-1$ eigenstate of $Z$.</span></span>
<span data-ttu-id="5f11b-192">Sie verfügt über eine Signatur `((Double, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-192">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-193">`R1(phi,_)` ist identisch mit `R(PauliZ,phi,_)` gefolgt von `R(PauliI,-phi,_)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-193">`R1(phi,_)` is the same as `R(PauliZ,phi,_)` followed by `R(PauliI,-phi,_)`.</span></span>

<span data-ttu-id="5f11b-194">Der <xref:microsoft.quantum.intrinsic.r1frac>-Vorgang implementiert eine Bruch Bruch Drehung um den angegebenen Betrag um den Z = 1-eigen Zustand.</span><span class="sxs-lookup"><span data-stu-id="5f11b-194">The <xref:microsoft.quantum.intrinsic.r1frac> operation implements a fractional rotation by the given amount around the Z=1 eigenstate.</span></span>
<span data-ttu-id="5f11b-195">Sie verfügt über eine Signatur `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-195">It has signature `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-196">`R1Frac(k,n,_)` ist identisch mit `RFrac(PauliZ,-k.n+1,_)` gefolgt von `RFrac(PauliI,k,n+1,_)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-196">`R1Frac(k,n,_)` is the same as `RFrac(PauliZ,-k.n+1,_)` followed by `RFrac(PauliI,k,n+1,_)`.</span></span>

<span data-ttu-id="5f11b-197">Im folgenden wird ein Beispiel für einen Rotations Vorgang (um die in der Bloch-Kugel zugeordnete Pauli-$Z $-Achse) dargestellt:</span><span class="sxs-lookup"><span data-stu-id="5f11b-197">An example of a rotation operation (around the Pauli $Z$ axis, in this instance) mapped onto the Bloch sphere is shown below:</span></span>

![Drehvorgang auf der Bloch-Kugel zugeordnet](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a><span data-ttu-id="5f11b-199">Multiqubit-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="5f11b-199">Multi-Qubit Operations</span></span> ####

<span data-ttu-id="5f11b-200">Zusätzlich zu den oben beschriebenen Single-Qubit-Vorgängen definiert der-Auftakt auch mehrere multiqubit-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="5f11b-200">In addition to the single-qubit operations above, the prelude also defines several multi-qubit operations.</span></span>

<span data-ttu-id="5f11b-201">Zuerst führt der <xref:microsoft.quantum.intrinsic.cnot> Vorgang ein Standardmäßiges kontrolliertes`NOT` Gate aus, \begin{Equation} \operatschmue{CNOT} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="5f11b-201">First, the <xref:microsoft.quantum.intrinsic.cnot> operation performs a standard controlled-`NOT` gate, \begin{equation} \operatorname{CNOT} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span></span>
<span data-ttu-id="5f11b-202">\end{Equation} es weist eine Signatur `((Qubit, Qubit) => Unit is Adj + Ctl)`auf, die angibt, dass $ \operatorname{CNOT} $ auf zwei einzelnen Qubits einheitlich agiert.</span><span class="sxs-lookup"><span data-stu-id="5f11b-202">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`, representing that $\operatorname{CNOT}$ acts unitarily on two individual qubits.</span></span>
<span data-ttu-id="5f11b-203">`CNOT(q1, q2)` ist identisch mit `(Controlled X)([q1], q2)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-203">`CNOT(q1, q2)` is the same as `(Controlled X)([q1], q2)`.</span></span>
<span data-ttu-id="5f11b-204">Da das `Controlled`-Funktor das Steuern von für ein Register ermöglicht, verwenden wir das Array Literale `[q1]`, um anzugeben, dass nur das einzige Steuerelement verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="5f11b-204">Since the `Controlled` functor allows for controlling on a register, we use the array literal `[q1]` to indicate that we want only the one control.</span></span>

<span data-ttu-id="5f11b-205">Der <xref:microsoft.quantum.intrinsic.ccnot> Vorgang führt ein doppelt kontrolliertes not-Gate durch, das manchmal auch als "tffoli Gate" bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="5f11b-205">The <xref:microsoft.quantum.intrinsic.ccnot> operation performs doubly-controlled NOT gate, sometimes also known as the Toffoli gate.</span></span>
<span data-ttu-id="5f11b-206">Sie verfügt über eine Signatur `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-206">It has signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-207">`CCNOT(q1, q2, q3)` ist identisch mit `(Controlled X)([q1, q2], q3)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-207">`CCNOT(q1, q2, q3)` is the same as `(Controlled X)([q1, q2], q3)`.</span></span>

<span data-ttu-id="5f11b-208">Der <xref:microsoft.quantum.intrinsic.swap> Vorgang tauscht die Quantum-Zustände von zwei Qubits aus.</span><span class="sxs-lookup"><span data-stu-id="5f11b-208">The <xref:microsoft.quantum.intrinsic.swap> operation swaps the quantum states of two qubits.</span></span>
<span data-ttu-id="5f11b-209">Das heißt, es implementiert die einheitliche Matrix \begin{Equation} \operatorname{tauap} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="5f11b-209">That is, it implements the unitary matrix \begin{equation} \operatorname{SWAP} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span></span>
<span data-ttu-id="5f11b-210">\end{Equation} verfügt über eine Signatur `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-210">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="5f11b-211">`SWAP(q1,q2)` entspricht `CNOT(q1, q2)`, gefolgt von `CNOT(q2, q1)` und dann `CNOT(q1, q2)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-211">`SWAP(q1,q2)` is equivalent to `CNOT(q1, q2)` followed by `CNOT(q2, q1)` and then `CNOT(q1, q2)`.</span></span>

> [!NOTE]
> <span data-ttu-id="5f11b-212">Das austauschgate ist *nicht* identisch mit dem Neuanordnen der Elemente einer Variablen mit dem Typ `Qubit[]`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-212">The SWAP gate is *not* the same as rearranging the elements of a variable with type `Qubit[]`.</span></span>
> <span data-ttu-id="5f11b-213">Das Anwenden von `SWAP(q1, q2)` bewirkt eine Änderung des Status der Qubits, auf die von `q1` und `q2`verwiesen wird. `let swappedRegister = [q2, q1];` wirkt sich nur darauf aus, wie auf diese Qubits verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="5f11b-213">Applying `SWAP(q1, q2)` causes a change to the state of the qubits referred to by `q1` and `q2`, while `let swappedRegister = [q2, q1];` only affects how we refer to those qubits.</span></span>
> <span data-ttu-id="5f11b-214">Darüber hinaus ermöglicht `(Controlled SWAP)([q0], (q1, q2))`, dass `SWAP` auf den Zustand eines dritten Qubit, das nicht durch Neuanordnen von Elementen dargestellt werden kann, bedingt ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-214">Moreover, `(Controlled SWAP)([q0], (q1, q2))` allows for `SWAP` to be conditioned on the state of a third qubit, which we cannot represent by rearranging elements.</span></span>
> <span data-ttu-id="5f11b-215">Das Tor des kontrollierten Austauschs, das auch als "Fredkin Gate" bezeichnet wird, ist leistungsfähig genug, um die gesamte klassische Berechnung einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-215">The controlled-SWAP gate, also known as the Fredkin gate, is powerful enough to include all classical computation.</span></span>

<span data-ttu-id="5f11b-216">Schließlich bietet das präspiel zwei Vorgänge zum Darstellen von exponentialen von multiqubit-Pauli-Operatoren.</span><span class="sxs-lookup"><span data-stu-id="5f11b-216">Finally, the prelude provides two operations for representing exponentials of multi-qubit Pauli operators.</span></span>
<span data-ttu-id="5f11b-217">Der <xref:microsoft.quantum.intrinsic.exp> Vorgang führt eine Drehung auf Grundlage eines tensorflow-Produkts von Pauli-Matrizen durch, wie durch das Multi-Qubit-einheitliches \begin{Equation} \operatorname{Exp} (\vec{\sigma}) dargestellt. \phi) \mathrel{: =} \exp\left (i \phi \ sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation} WHERE $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ ist eine Sequenz von Single-Qubit-Pauli-Operatoren, wobei $ \phi $ ein Winkel ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-217">The <xref:microsoft.quantum.intrinsic.exp> operation performs a rotation based on a tensor product of Pauli matrices, as represented by the multi-qubit unitary \begin{equation} \operatorname{Exp}(\vec{\sigma}, \phi) \mathrel{:=} \exp\left(i \phi \sigma_0 \otimes \sigma_1 \otimes \cdots \otimes \sigma_n \right), \end{equation} where $\vec{\sigma} = (\sigma_0, \sigma_1, \dots, \sigma_n)$ is a sequence of single-qubit Pauli operators, and where $\phi$ is an angle.</span></span>
<span data-ttu-id="5f11b-218">Die `Exp` Drehung stellt "$ \vec{\sigma} $" als Array von `Pauli` Elementen dar, sodass Sie über eine Signatur `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`verfügt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-218">The `Exp` rotation represents $\vec{\sigma}$ as an array of `Pauli` elements, such that it has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="5f11b-219">Der <xref:microsoft.quantum.intrinsic.expfrac> Vorgang führt dieselbe Drehung aus, wobei die oben beschriebene dyadic-Bruch Notation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5f11b-219">The <xref:microsoft.quantum.intrinsic.expfrac> operation performs the same rotation, using the dyadic fraction notation discussed above.</span></span>
<span data-ttu-id="5f11b-220">Sie verfügt über eine Signatur `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-220">It has signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

> [!WARNING]
> <span data-ttu-id="5f11b-221">Exponentiale des tensorflow-Produkts von Pauli-Operatoren sind nicht mit tensorflow-Produkten der exponentiale von Pauli-Operatoren identisch.</span><span class="sxs-lookup"><span data-stu-id="5f11b-221">Exponentials of the tensor product of Pauli operators are not the same as tensor products of the exponentials of Pauli operators.</span></span>
> <span data-ttu-id="5f11b-222">Das heißt, $e ^ {i (z \otimes Z) \phi} \nE e ^ {i z \phi} \otimes e ^ {i z \phi} $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-222">That is, $e^{i (Z \otimes Z) \phi} \ne e^{i Z \phi} \otimes e^{i Z \phi}$.</span></span>

### <a name="measurements"></a><span data-ttu-id="5f11b-223">Messungen</span><span class="sxs-lookup"><span data-stu-id="5f11b-223">Measurements</span></span> ###

<span data-ttu-id="5f11b-224">Beim Messen entspricht der + 1-eigen Wert des gemessenen Operators einem `Zero` Ergebnis und dem Eigen Wert-1 für ein `One` Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="5f11b-224">When measuring, the +1 eigenvalue of the operator being measured corresponds to a `Zero` result, and the -1 eigenvalue to a `One` result.</span></span>

> [!NOTE]
> <span data-ttu-id="5f11b-225">Diese Konvention mag merkwürdig erscheinen, hat jedoch zwei sehr gute Vorteile.</span><span class="sxs-lookup"><span data-stu-id="5f11b-225">While this convention might seem odd, it has two very nice advantages.</span></span>
> <span data-ttu-id="5f11b-226">Zuerst wird das Ergebnis "$ \ket{0}$" durch den `Result` Wert `Zero`dargestellt, während "$ \ket{1}$" `One`entspricht.</span><span class="sxs-lookup"><span data-stu-id="5f11b-226">First, observing the outcome $\ket{0}$ is represented by the `Result` value `Zero`, while observing $\ket{1}$ corresponds to `One`.</span></span>
> <span data-ttu-id="5f11b-227">Zweitens können wir heraus schreiben, dass der Eigen Wert $ \lambda $, der einem Ergebnis $r $ entspricht, $ \lambda = (-1) ^ r $ entspricht.</span><span class="sxs-lookup"><span data-stu-id="5f11b-227">Second, we can write out that the eigenvalue $\lambda$ corresponding to a result $r$ is $\lambda = (-1)^r$.</span></span>

<span data-ttu-id="5f11b-228">Messvorgänge unterstützen weder den `Adjoint` noch den `Controlled`-Funktor.</span><span class="sxs-lookup"><span data-stu-id="5f11b-228">Measurement operations support neither the `Adjoint` nor the `Controlled` functor.</span></span>

<span data-ttu-id="5f11b-229">Der <xref:microsoft.quantum.intrinsic.measure> Vorgang führt eine gemeinsame Messung von einem oder mehreren Qubits im angegebenen Produkt von Pauli-Operatoren aus.</span><span class="sxs-lookup"><span data-stu-id="5f11b-229">The <xref:microsoft.quantum.intrinsic.measure> operation performs a joint measurement of one or more qubits in the specified product of Pauli operators.</span></span>
<span data-ttu-id="5f11b-230">Wenn die Länge des Pauli-Arrays und des Qubit-Arrays unterschiedlich ist, schlägt der Vorgang fehl.</span><span class="sxs-lookup"><span data-stu-id="5f11b-230">If the Pauli array and qubit array are different lengths, then the operation fails.</span></span>
<span data-ttu-id="5f11b-231">`Measure` verfügt über eine Signatur `((Pauli[], Qubit[]) => Result)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-231">`Measure` has signature `((Pauli[], Qubit[]) => Result)`.</span></span>

<span data-ttu-id="5f11b-232">Beachten Sie, dass eine gemeinsame Messung nicht mit der Messung der einzelnen Qubits identisch ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-232">Note that a joint measurement is not the same as measuring each qubit individually.</span></span>
<span data-ttu-id="5f11b-233">Sehen Sie sich beispielsweise den Status $ \ket{11} = \ket{1} \otimes \ket{1} = x\otimes X \ket{00}$ an.</span><span class="sxs-lookup"><span data-stu-id="5f11b-233">For example, consider the state $\ket{11} = \ket{1} \otimes \ket{1} = X\otimes X \ket{00}$.</span></span>
<span data-ttu-id="5f11b-234">Wenn Sie $Z _0 $ und $Z _1 $ einzeln Messen, erhalten wir die Ergebnisse $r _0 = $1 und $r _1 = $1.</span><span class="sxs-lookup"><span data-stu-id="5f11b-234">Measuring $Z_0$ and $Z_1$ each individually, we get the results $r_0 = 1$ and $r_1 = 1$.</span></span>
<span data-ttu-id="5f11b-235">Wenn Sie $Z _0 Z_1 $ Messen, erhalten wir jedoch das einzige Ergebnis $r _ {\textrm{Joint}} = $0, das angibt, dass die Größe von $ \ket{11}$ positiv ist.</span><span class="sxs-lookup"><span data-stu-id="5f11b-235">Measuring $Z_0 Z_1$, however, we get the single result $r_{\textrm{joint}} = 0$, representing that the pairity of $\ket{11}$ is positive.</span></span>
<span data-ttu-id="5f11b-236">Unterschiedlich platzieren, $ (-1) ^ {r_0 + r_1} = (-1) ^ R_ {\textrm{Joint}}) $.</span><span class="sxs-lookup"><span data-stu-id="5f11b-236">Put differently, $(-1)^{r_0 + r_1} = (-1)^r_{\textrm{joint}})$.</span></span>
<span data-ttu-id="5f11b-237">Da wir *nur* die Parität dieser Messung erlernen, werden alle Quantum-Informationen, die in der übergeordneten Position zwischen den 2 2-Qubit-Zuständen der positiven Parität ($ \ket{00}$ und $ \ket{11}$) dargestellt werden, beibehalten.</span><span class="sxs-lookup"><span data-stu-id="5f11b-237">Critically, since we *only* learn the parity from this measurement, any quantum information represented in the superposition between the two two-qubit states of positive parity, $\ket{00}$ and $\ket{11}$, is preserved.</span></span>
<span data-ttu-id="5f11b-238">Diese Eigenschaft ist später erforderlich, da wir die Fehlerkorrektur erörtern.</span><span class="sxs-lookup"><span data-stu-id="5f11b-238">This property will be essential later, as we discuss error correction.</span></span>

<span data-ttu-id="5f11b-239">Der Vorteil ist, dass die Einleitung auch zwei weitere Vorgänge zum Messen von Qubits bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="5f11b-239">For convenience, the prelude also provides two other operations for measuring qubits.</span></span>
<span data-ttu-id="5f11b-240">Da das Ausführen von Single-Qubit-Messungen recht häufig ist, definiert das präspiel eine kurzzahl für diesen Fall.</span><span class="sxs-lookup"><span data-stu-id="5f11b-240">First, since performing single-qubit measurements is quite common, the prelude defines a shorthand for this case.</span></span>
<span data-ttu-id="5f11b-241">Der <xref:microsoft.quantum.intrinsic.m>-Vorgang misst den Pauli-$Z $-Operator auf einem einzelnen Qubit und verfügt über eine Signatur `(Qubit => Result)`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-241">The <xref:microsoft.quantum.intrinsic.m> operation measures the Pauli $Z$ operator on a single qubit, and has signature `(Qubit => Result)`.</span></span>
<span data-ttu-id="5f11b-242">`M(q)` entspricht `Measure([PauliZ], [q])`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-242">`M(q)` is equivalent to `Measure([PauliZ], [q])`.</span></span>

<span data-ttu-id="5f11b-243">Der <xref:microsoft.quantum.measurement.multim> misst den Pauli $Z $-Operator *separat* für jedes Array von Qubits und gibt das *Array* von `Result` Werten zurück, die für jedes Qubit abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5f11b-243">The <xref:microsoft.quantum.measurement.multim> measures the Pauli $Z$ operator *separately* on each of an array of qubits, returning the *array* of `Result` values obtained for each qubit.</span></span>
<span data-ttu-id="5f11b-244">In einigen Fällen kann dies optimiert werden.</span><span class="sxs-lookup"><span data-stu-id="5f11b-244">In some cases this can be optimized.</span></span> <span data-ttu-id="5f11b-245">Sie verfügt über eine Signatur (`Qubit[] => Result[])`.</span><span class="sxs-lookup"><span data-stu-id="5f11b-245">It has signature (`Qubit[] => Result[])`.</span></span>
<span data-ttu-id="5f11b-246">`MultiM(qs)` ist äquivalent zu:</span><span class="sxs-lookup"><span data-stu-id="5f11b-246">`MultiM(qs)` is equivalent to:</span></span>

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a><span data-ttu-id="5f11b-247">Erweiterungsfunktionen und-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="5f11b-247">Extension Functions and Operations</span></span> ##

<span data-ttu-id="5f11b-248">Außerdem definiert der-Auftakt einen umfangreichen Satz mathematischer und Typkonvertierungs Funktionen auf der .NET-Ebene für die Verwendung in Q #-Code.</span><span class="sxs-lookup"><span data-stu-id="5f11b-248">In addition, the prelude defines a rich set of mathematical and type conversion functions at the .NET level for use within Q# code.</span></span>
<span data-ttu-id="5f11b-249">Der <xref:microsoft.quantum.extensions.math>-Namespace definiert z. b. nützliche Vorgänge, z. b. <xref:microsoft.quantum.extensions.math.sin> und <xref:microsoft.quantum.extensions.math.log>.</span><span class="sxs-lookup"><span data-stu-id="5f11b-249">For instance, the <xref:microsoft.quantum.extensions.math> namespace defines useful operations such as <xref:microsoft.quantum.extensions.math.sin> and <xref:microsoft.quantum.extensions.math.log>.</span></span>
<span data-ttu-id="5f11b-250">Die vom Quantum Development Kit bereitgestellte Implementierung verwendet die klassische .net-Basisklassen Bibliothek und kann daher einen zusätzlichen kommunikationsroundtrip zwischen Quantum-Programmen und ihren klassischen Treibern beinhalten.</span><span class="sxs-lookup"><span data-stu-id="5f11b-250">The implementation provided by the Quantum Development Kit uses the classical .NET base class library, and thus may involve an additional communications round trip between quantum programs and their classical drivers.</span></span>
<span data-ttu-id="5f11b-251">Dies stellt zwar kein Problem für einen lokalen Simulator dar, dies kann jedoch bei der Verwendung eines Remote Simulators oder der tatsächlichen Hardware als Zielcomputer ein Leistungsproblem darstellen.</span><span class="sxs-lookup"><span data-stu-id="5f11b-251">While this does not present a problem for a local simulator, this can be a performance issue when using a remote simulator or actual hardware as a target machine.</span></span>
<span data-ttu-id="5f11b-252">Dies bedeutet, dass ein einzelner Zielcomputer diese Auswirkungen auf die Leistung verringern kann, indem er diese Vorgänge mit Versionen außer Kraft setzt, die für das jeweilige System effizienter sind.</span><span class="sxs-lookup"><span data-stu-id="5f11b-252">That said, an individual target machine may mitigate this performance impact by overriding these operations with versions that are more efficient for that particular system.</span></span>

### <a name="math"></a><span data-ttu-id="5f11b-253">Mathematisch</span><span class="sxs-lookup"><span data-stu-id="5f11b-253">Math</span></span> ###

<span data-ttu-id="5f11b-254">Der <xref:microsoft.quantum.extensions.math>-Namespace stellt viele nützliche Funktionen aus der [`System.Math` Klasse](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1)der .net-Basisklassen Bibliothek bereit.</span><span class="sxs-lookup"><span data-stu-id="5f11b-254">The <xref:microsoft.quantum.extensions.math> namespace provides many useful functions from the .NET base class library's [`System.Math` class](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1).</span></span>
<span data-ttu-id="5f11b-255">Diese Funktionen können auf die gleiche Weise wie alle anderen Q #-Funktionen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="5f11b-255">These functions can be used in the same manner as any other Q# functions:</span></span>

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

<span data-ttu-id="5f11b-256">Wenn eine statische .NET-Methode basierend auf dem Typ ihrer Argumente überladen wurde, wird die entsprechende Q #-Funktion mit einem Suffix kommentiert, das den Typ der Eingabe angibt:</span><span class="sxs-lookup"><span data-stu-id="5f11b-256">Where a .NET static method has been overloaded based on the type of its arguments, the corresponding Q# function is annotated with a suffix indicating the type of its input:</span></span>

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a><span data-ttu-id="5f11b-257">Bitweise Vorgänge</span><span class="sxs-lookup"><span data-stu-id="5f11b-257">Bitwise Operations</span></span> ###

<span data-ttu-id="5f11b-258">Schließlich stellt der <xref:microsoft.quantum.extensions.bitwise>-Namespace mehrere nützliche Funktionen zum Bearbeiten ganzer Zahlen durch bitweise Operatoren bereit.</span><span class="sxs-lookup"><span data-stu-id="5f11b-258">Finally, the <xref:microsoft.quantum.extensions.bitwise> namespace provides several useful functions for manipulating integers through bitwise operators.</span></span>
<span data-ttu-id="5f11b-259">Beispielsweise gibt <xref:microsoft.quantum.extensions.bitwise.parity> die bitweise Parität einer Ganzzahl als eine andere Ganzzahl zurück.</span><span class="sxs-lookup"><span data-stu-id="5f11b-259">For instance, <xref:microsoft.quantum.extensions.bitwise.parity> returns the bitwise parity of an integer as another integer.</span></span>
