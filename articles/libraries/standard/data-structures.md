---
title: 'F #-Standardbibliotheken-Datenstrukturen | Microsoft-Dokumentation'
description: 'F #-Standardbibliotheken-Datenstrukturen'
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e8b28561f1aba37cb5bf41c6176386d19bfacf06
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/27/2019
ms.locfileid: "73184507"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="72fb1-103">Datenstrukturen und Modellierung</span><span class="sxs-lookup"><span data-stu-id="72fb1-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="72fb1-104">Klassische Datenstrukturen</span><span class="sxs-lookup"><span data-stu-id="72fb1-104">Classical Data Structures</span></span> ##

<span data-ttu-id="72fb1-105">Zusammen mit benutzerdefinierten Typen für die Darstellung von Quantum-Konzepten stellt der Kanon auch Vorgänge, Funktionen und Typen für die Arbeit mit klassischen Daten bereit, die bei der Steuerung von Quantum-Systemen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="72fb1-106">Die <xref:microsoft.quantum.arrays.reversed>-Funktion nimmt beispielsweise ein Array als Eingabe an und gibt dasselbe Array in umgekehrter Reihenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="72fb1-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="72fb1-107">Dies kann dann für ein Array vom Typ `Qubit[]` verwendet werden, um zu vermeiden, dass unnötige $ \operatschmue{curap} $ Gates beim Konvertieren zwischen den ganzen Zahlen von ganzen Zahlen angewendet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="72fb1-108">Ebenso haben wir im vorherigen Abschnitt gesehen, dass Formular `(Int, Int -> T)` für die Darstellung von zufälligen Zugriffs Auflistungen nützlich sein können, sodass die <xref:microsoft.quantum.arrays.lookupfunction>-Funktion eine Möglichkeit bietet, solche Typen aus Array Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convienent way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="72fb1-109">Chen</span><span class="sxs-lookup"><span data-stu-id="72fb1-109">Pairs</span></span> ###

<span data-ttu-id="72fb1-110">Der Kanon unterstützt die Funktionsweise Notation für Paare, was den Zugriff auf Tupel durch die decoerstellung ergänzt:</span><span class="sxs-lookup"><span data-stu-id="72fb1-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="72fb1-111">Arrays</span><span class="sxs-lookup"><span data-stu-id="72fb1-111">Arrays</span></span> ###

<span data-ttu-id="72fb1-112">Der Kanon stellt mehrere Funktionen zum Bearbeiten von Arrays bereit.</span><span class="sxs-lookup"><span data-stu-id="72fb1-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="72fb1-113">Diese Funktionen sind typparametrisiert und können daher mit Arrays beliebiger Q #-Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="72fb1-114">Die <xref:microsoft.quantum.arrays.reversed>-Funktion gibt beispielsweise ein neues Array zurück, dessen Elemente in umgekehrter Reihenfolge von der Eingabe sind.</span><span class="sxs-lookup"><span data-stu-id="72fb1-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="72fb1-115">Dies kann verwendet werden, um zu ändern, wie ein Quantum-Register beim Aufrufen von Vorgängen dargestellt wird:</span><span class="sxs-lookup"><span data-stu-id="72fb1-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="72fb1-116">Ebenso kann die <xref:microsoft.quantum.arrays.subarray>-Funktion verwendet werden, um die Elemente eines Arrays neu anzuordnen oder Teilmengen zu nehmen:</span><span class="sxs-lookup"><span data-stu-id="72fb1-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="72fb1-117">In Kombination mit der Fluss Steuerung können Array Bearbeitungsfunktionen wie <xref:microsoft.quantum.arrays.zip> eine leistungsstarke Möglichkeit zum Ausdrücken von Quantum-Programmen bieten:</span><span class="sxs-lookup"><span data-stu-id="72fb1-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="72fb1-118">Oracles</span><span class="sxs-lookup"><span data-stu-id="72fb1-118">Oracles</span></span> ##

<span data-ttu-id="72fb1-119">In der Literatur der [Phasen Schätzung](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) und der [Amplitude-Verstärkung](https://en.wikipedia.org/wiki/Amplitude_amplification) erscheint das Konzept eines Oracle häufig.</span><span class="sxs-lookup"><span data-stu-id="72fb1-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="72fb1-120">Hier bezieht sich der Begriff Oracle auf eine blackboxtests-Quantum-Unterroutine, die auf einen Satz von Qubits anwendet und die Antwort als Phase zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="72fb1-121">Diese Unterroutine kann sich oft als Eingabe für einen Quantum-Algorithmus vorstellen, der das Oracle zusätzlich zu einigen anderen Parametern annimmt, und eine Reihe von Quantum-Vorgängen anwendet und einen aufzurufenden aufrufungs Vorgang als grundlegende Gate behandelt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="72fb1-122">Um den größeren Algorithmus tatsächlich zu implementieren, muss eine konkrete Zerlegung des Oracle in grundlegende Gates bereitgestellt werden, aber eine solche Zerlegung ist nicht erforderlich, um den Algorithmus zu verstehen, der das Oracle aufruft.</span><span class="sxs-lookup"><span data-stu-id="72fb1-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="72fb1-123">In f # wird diese Abstraktion mithilfe von Vorgängen als erstklassige Werte dargestellt, sodass Vorgänge in einer Blackbox-Weise an Implementierungen von Quantum-Algorithmen übermittelt werden können.</span><span class="sxs-lookup"><span data-stu-id="72fb1-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="72fb1-124">Außerdem werden benutzerdefinierte Typen verwendet, um die verschiedenen Oracle-Darstellungen auf typsichere Weise zu bezeichnen. dadurch ist es schwierig, unterschiedliche Arten von Black Box-Vorgängen versehentlich zu verscheihen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidently conflate different kinds of black box operations.</span></span>

<span data-ttu-id="72fb1-125">Solche Oracles werden in verschiedenen Kontexten angezeigt, einschließlich bekannter Beispiele wie [der Such-und Quantum-Simulations Algorithmen von Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) .</span><span class="sxs-lookup"><span data-stu-id="72fb1-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="72fb1-126">Hier konzentrieren wir uns auf die Oracles, die nur für zwei Anwendungen benötigt werden: Amplitude-Verstärkung und Phasen Schätzung.</span><span class="sxs-lookup"><span data-stu-id="72fb1-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="72fb1-127">Zuerst werden Amplitude-Verstärkungs-Oracles behandelt, bevor die Phasen Schätzung erfolgt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-127">We will first discuss amplitude amplification oracles before proceding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="72fb1-128">Amplitude-Verstärkungs-Oracles</span><span class="sxs-lookup"><span data-stu-id="72fb1-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="72fb1-129">Der Amplitude-Verstärkungs Algorithmus zielt darauf ab, eine Drehung zwischen einem Anfangszustand und einem Endzustand durch Anwenden einer Sequenz von Reflektionen des Zustands auszuführen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="72fb1-130">Damit der Algorithmus funktionsfähig ist, muss er beide Zustände angeben.</span><span class="sxs-lookup"><span data-stu-id="72fb1-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="72fb1-131">Diese Spezifikationen werden durch zwei Oracles angegeben.</span><span class="sxs-lookup"><span data-stu-id="72fb1-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="72fb1-132">Diese Oracles funktionieren durch Aufteilen der Eingaben in zwei Leerzeichen, einem "Ziel"-Teilbereich und einem "ursprünglichen" Teilbereich.</span><span class="sxs-lookup"><span data-stu-id="72fb1-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="72fb1-133">Die Oracles identifizieren solche Teilbereiche, ähnlich wie bei der Verwendung von "Pauli"-Operatoren zwei Leerzeichen, indem Sie eine $ \pm $1-Phase auf diese Leerzeichen anwenden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="72fb1-134">Der Hauptunterschied besteht darin, dass diese Leerzeichen in dieser Anwendung keine halben Leerzeichen sein müssen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="72fb1-135">Beachten Sie auch, dass diese beiden Teilbereiche sich nicht gegenseitig ausschließen: Es werden Vektoren vorhanden sein, die Mitglieder beider Leerzeichen sind.</span><span class="sxs-lookup"><span data-stu-id="72fb1-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="72fb1-136">Wenn dies nicht der Fall ist, hätte die Amplitude-Verstärkung keine Auswirkung, daher benötigen wir den ursprünglichen Teilbereich, um eine Überschneidung ungleich NULL mit dem Ziel Teilbereich zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="72fb1-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="72fb1-137">Wir bezeichnen das erste Oracle, das wir benötigen, damit die Amplitude-Verstärkung $P\_$0 ist, das für die folgende Aktion definiert ist.</span><span class="sxs-lookup"><span data-stu-id="72fb1-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="72fb1-138">Für alle Zustände $ \ket{x} $ im "ursprünglichen" Teilbereich $P\_0 \ket{x} =-\ket{x} $ und für alle Zustände $ \ket{y} $, die nicht in diesem Teilbereich liegen, wird $P\_0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="72fb1-139">Das Oracle, das den Ziel Teilbereich ($P _1 $) kennzeichnet, hat genau dasselbe Formular.</span><span class="sxs-lookup"><span data-stu-id="72fb1-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="72fb1-140">Für alle Zustände $ \ket{x} $ im Ziel Teilbereich (d. h. für alle Zustände, die der Algorithmus ausgeben soll), $P _1 \ Ket {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="72fb1-141">Gleiches gilt für alle Zustände $ \ket{y} $, die sich nicht im Ziel Teilbereich befinden $P _1 \ Ket {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="72fb1-142">Diese beiden Reflektionen werden dann kombiniert, um einen Operator zu bilden, der einen einzelnen Schritt der Amplitude-Verstärkung $Q =-P_0 P_1 $, wobei das Gesamt Minuszeichen nur in kontrollierten Anwendungen berücksichtigt werden muss.</span><span class="sxs-lookup"><span data-stu-id="72fb1-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="72fb1-143">Die Amplitude-Verstärkung wird dann durchgeführt, indem ein Anfangszustand ($ \ket{\psi} $), der sich im ursprünglichen Teilbereich befindet, übernommen und dann "$ \ket{\psi} \mapsto Q ^ m \ket{\psi} $" durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="72fb1-144">Wenn eine solche Iteration durchgeführt wird, wird sichergestellt, dass bei einem Anfangszustand, der den Wert $ \sin ^ 2 (\urta) $ mit dem markierten Bereich aufweist, nach $m $-Iterationen $ \sin ^ 2 ([2M + 1] \urta) $ geändert wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="72fb1-145">Daher möchten wir in der Regel $m $ auswählen, um einen kostenlosen Parameter zu sein, z. b. $ [2M + 1] \Der Ta = \ Pi/2 $; Diese starren Optionen sind jedoch für einige Formen der Amplitude-Verstärkung nicht so wichtig, wie z. b. die Verstärkung der festen Punkt Amplitude.</span><span class="sxs-lookup"><span data-stu-id="72fb1-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="72fb1-146">Mit diesem Prozess können wir einen Status im markierten Teilbereich vorbereiten, indem Sie quadratisch weniger Abfragen an die Markierungs Funktion und die Zustands Vorbereitungs Funktion als auf einem streng klassischen Gerät durchführt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="72fb1-147">Aus diesem Grund ist die Amplitude-Verstärkung ein bedeutender Baustein für viele Anwendungen von Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="72fb1-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="72fb1-148">Um zu verstehen, wie der Algorithmus verwendet wird, ist es hilfreich, ein Beispiel bereitzustellen, das eine Konstruktion der Oracles ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="72fb1-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="72fb1-149">Sie sollten in dieser Einstellung einen Grover-Algorithmus für Daten Bank Suchvorgänge ausführen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="72fb1-150">In der Grover-Suche besteht das Ziel darin, den Status $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket{0}$ in einen der (potenziell) vielen markierten Zustände umzuwandeln.</span><span class="sxs-lookup"><span data-stu-id="72fb1-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="72fb1-151">Um dies zu vereinfachen, sehen wir uns nur den Fall an, in dem der einzige markierte Status $ \ket{0}$ ist.</span><span class="sxs-lookup"><span data-stu-id="72fb1-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="72fb1-152">Anschließend haben wir zwei Oracles entworfen: eine, die nur den Anfangszustand $ \ket{+} ^ {\otimes n} $ mit einem Minuszeichen kennzeichnet, und eine andere, die den markierten Zustand $ \ket{0}$ mit einem Minuszeichen kennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="72fb1-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="72fb1-153">Das letztere Gate kann mithilfe des folgenden Verarbeitungsvorgangs implementiert werden, indem die Ablauf Steuerungs Vorgänge in der Canon verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="72fb1-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="72fb1-154">Bei diesem Oracle handelt es sich dann um einen Sonderfall des <xref:microsoft.quantum.canon.rall1> Vorgangs, der das Drehen durch eine beliebige Phase anstelle des reflektionsingsfalls $ \phi = \pi $ ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="72fb1-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="72fb1-155">In diesem Fall ähnelt `RAll1` dem <xref:microsoft.quantum.intrinsic.r1>-aufzurufenden Vorgang, da er ungefähr $ \ket{11\cdots1} $ anstelle des Single-Qubit-Zustands $ \ket{1}$ rotiert.</span><span class="sxs-lookup"><span data-stu-id="72fb1-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="72fb1-156">Das Oracle, das den ursprünglichen Teilbereich markiert, kann auf ähnliche Weise erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="72fb1-157">In Pseudocode:</span><span class="sxs-lookup"><span data-stu-id="72fb1-157">In pseudocode:</span></span>

1. <span data-ttu-id="72fb1-158">Wenden Sie $H $ Gates auf alle Qubits an.</span><span class="sxs-lookup"><span data-stu-id="72fb1-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="72fb1-159">Wenden Sie $X $ Gates auf alle Qubits an.</span><span class="sxs-lookup"><span data-stu-id="72fb1-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="72fb1-160">Wenden Sie eine $n-$1-gesteuerte $Z $-Gate auf die $n ^ {\text{Th}} $ Qubit an.</span><span class="sxs-lookup"><span data-stu-id="72fb1-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="72fb1-161">Wenden Sie $X $ Gates auf alle Qubits an.</span><span class="sxs-lookup"><span data-stu-id="72fb1-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="72fb1-162">Wenden Sie $H $ Gates auf alle Qubits an.</span><span class="sxs-lookup"><span data-stu-id="72fb1-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="72fb1-163">Dieses Mal veranschaulichen wir auch die Verwendung von <xref:microsoft.quantum.canon.applywith> in Verbindung mit dem oben beschriebenen <xref:microsoft.quantum.canon.rall1> Vorgang:</span><span class="sxs-lookup"><span data-stu-id="72fb1-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="72fb1-164">Anschließend können Sie diese beiden Oracles miteinander kombinieren, um zwischen den beiden Zuständen zu drehen und $ \ket{+} ^ {\otimes n} $ in $ \ket{0}$ mithilfe von zu transformieren. eine Anzahl von Ebenen von Hadamard Gates, die proportional zu $ \sqrt{2 ^ n} $ (IE $m \propto \sqrt{2 ^ n} $) im Vergleich zu den ungefähr $2 ^ n $-Ebenen, die benötigt werden, um den $ \ket-{0}$ State auf nicht deterministische Weise vorzubereiten, indem Sie den Anfangszustand vorbereiten und Messen, bis das Ergebnis $0 $ beobachtet wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="72fb1-165">Phasen Schätz-Oracles</span><span class="sxs-lookup"><span data-stu-id="72fb1-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="72fb1-166">Bei der Phasen Schätzung sind die Oracles etwas natürlicher.</span><span class="sxs-lookup"><span data-stu-id="72fb1-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="72fb1-167">Das Ziel der Phasen Schätzung ist das Entwerfen einer Unterroutine, die eine Stichprobe aus den eigen Werten einer einheitlichen Matrix erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="72fb1-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="72fb1-168">Diese Methode ist in der Quantum-Simulation nicht zu verwenden, da diese Eigenwerte für viele physische Probleme in der Chemie und in der Materialwissenschaft die Boden Zustands Energien von Quantum-Systemen bereitstellen, die uns wertvolle Informationen zu den Phasen Diagrammen von Material and Reaction Dynamics für Moleküle.</span><span class="sxs-lookup"><span data-stu-id="72fb1-168">This method is indispensible in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="72fb1-169">Jede Konfiguration der Phasen Schätzung benötigt eine einheitliche Eingabe.</span><span class="sxs-lookup"><span data-stu-id="72fb1-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="72fb1-170">Diese einheitliche wird in der Regel durch einen von zwei Typen von Oracles beschrieben.</span><span class="sxs-lookup"><span data-stu-id="72fb1-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="72fb1-171">Beide unten beschriebenen Oracle-Typen werden in den Beispielen behandelt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="72fb1-172">Weitere Informationen zu kontinuierlichen Abfrage-Oracles finden Sie im Beispiel [ **phaseschätz.** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation)</span><span class="sxs-lookup"><span data-stu-id="72fb1-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation).</span></span>
> <span data-ttu-id="72fb1-173">Weitere Informationen zu diskreten Abfrage-Oracles finden Sie im Beispiel [ **isingphaseschätz.** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)</span><span class="sxs-lookup"><span data-stu-id="72fb1-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

<span data-ttu-id="72fb1-174">Der erste Oracle-Typ, der als diskretes Abfrage-Oracle bezeichnet wird und den <xref:microsoft.quantum.oracles.discreteoracle>des benutzerdefinierten Typs darstellt, umfasst einfach eine einheitliche Matrix.</span><span class="sxs-lookup"><span data-stu-id="72fb1-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="72fb1-175">Wenn $U $ die einheitliche ist, deren Eigenwerte wir schätzen möchten, ist das Oracle für $U $ einfach ein eigenständiger Wert für eine Unterroutine, die $U $ implementiert.</span><span class="sxs-lookup"><span data-stu-id="72fb1-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="72fb1-176">Beispielsweise kann $U $ der oben definierte Oracle $Q $ für die Amplitude-Schätzung sein.</span><span class="sxs-lookup"><span data-stu-id="72fb1-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="72fb1-177">Die Eigenwerte dieser Matrix können verwendet werden, um die Überlappung zwischen dem Anfangs-und dem Ziel Status, $ \sin ^ 2 (\teta) $, zu schätzen, wobei quadratisch weniger Stichproben verwendet werden, die andernfalls benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="72fb1-178">Dadurch wird die Anwendung der Phasen Schätzung mithilfe der Grover-Oracle-$Q $ als Eingabe für den Moniker der Amplitude-Schätzung verdient.</span><span class="sxs-lookup"><span data-stu-id="72fb1-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="72fb1-179">Eine andere gängige Anwendung, die häufig in der Quantum-metroologie verwendet wird, umfasst die Schätzung eines kleinen Drehwinkels.</span><span class="sxs-lookup"><span data-stu-id="72fb1-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="72fb1-180">Mit anderen Worten, wir möchten $ \Der TA $ für ein unbekanntes Drehungs Gate der Form $R _Z (\erta) $ schätzen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="72fb1-181">In solchen Fällen die Unterroutine, mit der wir interagieren würden, um diesen festgelegten Wert von $ \teta $ für das Gate zu erlernen, ist $ $ \begin{align} U & = R_z (\teta) \\\\ & = \begin{bmatrix} e ^ {-i \teta/2} & 0 \\\\ 0 & e ^ {i \ die \end{bmatrix}.-</span><span class="sxs-lookup"><span data-stu-id="72fb1-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="72fb1-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="72fb1-182">\end{align} $$</span></span>

<span data-ttu-id="72fb1-183">Der zweite Oracle-Typ, der in der Phasen Schätzung verwendet wird, ist die kontinuierliche Abfrage (Oracle), dargestellt durch den <xref:microsoft.quantum.oracles.continuousoracle>-Typ.</span><span class="sxs-lookup"><span data-stu-id="72fb1-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="72fb1-184">Ein kontinuierliches Oracle-Abfrage für die Phasen Schätzung hat die Form $U (t) $, wobei $t $ eine klassisch bekannte reelle Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="72fb1-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="72fb1-185">Wenn $U $ eine einheitliche einheitliche ist, übernimmt das Oracle für die kontinuierliche Abfrage das Formular $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="72fb1-186">Dies ermöglicht es uns, Matrizen, wie z. b. $ \sqrt{u} $, abzufragen, die nicht direkt im diskreten Abfrage Modell implementiert werden konnten.</span><span class="sxs-lookup"><span data-stu-id="72fb1-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="72fb1-187">Diese Art von Oracle ist wertvoll, wenn Sie nicht eine bestimmte einheitliche, sondern die Eigenschaften des Generators der einheitlich erlernen möchten.</span><span class="sxs-lookup"><span data-stu-id="72fb1-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="72fb1-188">Beispielsweise ist in Dynamical Quantum Simulation das Ziel, Quantum-Verbindungen zu entwickeln, die $U (t) = e ^ {-i H t} $ für eine hermitische Matrix $H $ und Evolution time $t $ ähneln.</span><span class="sxs-lookup"><span data-stu-id="72fb1-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="72fb1-189">Die Eigenwerte $U (t) $ sind direkt mit den eigen Werten von $H $ verknüpft.</span><span class="sxs-lookup"><span data-stu-id="72fb1-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="72fb1-190">Um dies zu sehen, betrachten Sie einen eigen Vektor $H $: $H \ket{e} = e\ket {e} $, dann ist es leicht, von der Energie Reihen Definition der Matrix exponentialweise zu sehen, dass $U (t) \ket{e} = e ^ {i\phi} \ Ket {E} = e ^ {-IET} \ket{e} $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="72fb1-191">Wenn Sie die eigen Phase von $U (t) $ schätzen, erhält der Eigen Wert $E $, vorausgesetzt, dass der Eigen Vektor $ \ket{e} $ in den Phasen Schätz Algorithmus eingegeben wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="72fb1-192">In diesem Fall kann der Wert $t $ jedoch im Ermessen des Benutzers ausgewählt werden, da für einen ausreichend kleinen Wert $t $ der Eigen Wert $E $ eindeutig durch $E =-\ Phi/t $ uminvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="72fb1-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="72fb1-193">Da die Methoden der Quantum-Simulation die Möglichkeit bieten, eine nach Komma Breite auszuführen, werden Phasen Schätz Algorithmen bei der Abfrage der vereinheitzeit als zusätzliche Freiheit gewährt, insbesondere, wenn das diskrete Abfrage Modell nur unimining der Form zulässt $U ^ j $ um eine ganzzahlige $j $ zu erhalten, ermöglicht die kontinuierliche Abfrage Oracle uns, die unityder $U ^ t $ für beliebige reale Werte $t $ zu annähern.</span><span class="sxs-lookup"><span data-stu-id="72fb1-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="72fb1-194">Dies ist wichtig, um die letzte Unze Effizienz von Phasen Schätz Algorithmen zu unterdrücken, da es uns ermöglicht, genau das Experiment auszuwählen, das die meisten Informationen über $E $; Methoden, die auf diskreten Abfragen basieren, müssen jedoch durch die Auswahl der optimalen Anzahl von Abfragen im Algorithmus kompromittiert werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="72fb1-195">Als konkretes Beispiel hierfür sollten Sie das Problem beachten, dass nicht der Drehungs Winkel eines Gates, sondern die Häufigkeit eines rotierenden Quantums geschätzt wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="72fb1-196">Die einheitliche, die diese Quantum Dynamics beschreibt, ist $U (t) = R_z (2 \ Omega t) $ für die Entwicklungszeit $t $ und die unbekannte Häufigkeit $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="72fb1-197">In diesem Kontext können wir $U (t) $ für beliebige $t $ mithilfe eines einzelnen $R _Z $ Gate simulieren. Daher müssen Sie sich nicht auf einzelne Abfragen auf die einheitliche beschränken.</span><span class="sxs-lookup"><span data-stu-id="72fb1-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="72fb1-198">Ein solches kontinuierliches Modell verfügt auch über die-Eigenschaft, dass Häufigkeits Häufigkeits Angaben aus den Phasen Schätz Prozessen, die fortlaufende Abfragen verwenden, von Phaseninformationen erlernt werden können, die andernfalls durch die Verzweigungen der Logarithmus-Funktion maskiert werden. Sie können aus den Ergebnissen von Experimenten ersichtlich werden, die für nicht angemessene Werte von $t $ ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="72fb1-199">Aus diesem Grund sind Probleme, wie z. b. diese kontinuierlichen Abfrage Modelle für die Phasen Schätzung, nicht nur angemessen, sondern auch dem diskreten Abfrage Modell vorzuziehen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="72fb1-200">Aus diesem Grund verfügt Q # über Funktionen für beide Formen von Abfragen und überlassen Sie dem Benutzer die Entscheidung über einen Phasen Schätz Algorithmus, um die Anforderungen und den verfügbaren Oracle-Typ zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="72fb1-201">Dynamical Generator-Modellierung</span><span class="sxs-lookup"><span data-stu-id="72fb1-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="72fb1-202">Generatoren von Time-Evolution beschreiben, wie sich die Zustände im Laufe der Zeit weiterentwickeln.</span><span class="sxs-lookup"><span data-stu-id="72fb1-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="72fb1-203">Beispielsweise wird die Dynamics eines Quantum-Zustands $ \ket{\psi} $ von der Schrödinger-Gleichung $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)} gesteuert. \end{align} $ $ mit einer hermitian-Matrix $H $ (als "hamiltonan" bezeichnet) als Generator von Entschließungs.</span><span class="sxs-lookup"><span data-stu-id="72fb1-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="72fb1-204">Bei einem ersten Status von $ \ket{\psi (0)} $ at time $t = $0 ist die formale Lösung dieser Gleichung zum Zeitpunkt $t $ möglicherweise, schreiben Sie im Prinzip $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $, wobei die Matrix exponentielle $U (t) = e ^ {-i H t} $ als einheitlicher Time-Evolution-Operator.</span><span class="sxs-lookup"><span data-stu-id="72fb1-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="72fb1-205">Obwohl wir uns auf die Generatoren dieses Formulars konzentrieren, betonen wir, dass das Konzept allgemeiner angewendet wird, z. b. für die Simulation offener Quantum-Systeme oder für abstraktere differenzielle Gleichungen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="72fb1-206">Ein primäres Ziel der dynamischen Simulation ist die Implementierung des Time-Evolution-Operators in einem Quantum-Zustand, der in Qubits eines Quantum-Computers codiert ist.</span><span class="sxs-lookup"><span data-stu-id="72fb1-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="72fb1-207">In vielen Fällen kann der hamiltonan in eine Summe aus einigen $d $ einfacheren Begriffen aufgeteilt werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="72fb1-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="72fb1-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="72fb1-209">Wenn die Zeit Weiterentwicklung pro Begriff allein auf einem Quantum-Computer leicht zu implementieren ist.</span><span class="sxs-lookup"><span data-stu-id="72fb1-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="72fb1-210">Wenn $H _J $ beispielsweise ein Pauli-$X _1x_2 $-Operator ist, der auf die ersten und zweiten Elemente der Qubit-Register `qubits`wirkt, kann die Zeit Weiterentwicklung durch die IT für beliebige Zeit $t $ durch Aufrufen des Vorgangs `Exp([PauliX,PauliX], t, qubits[1..2])`, der über eine Signatur `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`verfügt, implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="72fb1-211">Wie weiter unten in der hamiltona-Simulation erläutert, besteht eine Lösung darin, die Zeit Weiterentwicklung durch $H $ mit einer Sequenz einfacher Vorgänge zu überarbeiten.</span><span class="sxs-lookup"><span data-stu-id="72fb1-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="72fb1-212">$ $ \begin{align} U (t) & = \left (e ^ {-IH\_0 t/r} e ^ {-IH\_1 t/r} \cdots e ^ {-IH\_{d-1} t/r} \right) ^ {r} + \mathcal{o} (d ^ 2 \max_j \\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="72fb1-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="72fb1-213">Dabei steuert die ganzzahlige $r > $0 den Näherungs Fehler.</span><span class="sxs-lookup"><span data-stu-id="72fb1-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="72fb1-214">Die Dynamical Generator Modeling Library bietet ein Framework für die systematische Codierung komplexer Generatoren in Bezug auf einfachere Generatoren.</span><span class="sxs-lookup"><span data-stu-id="72fb1-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="72fb1-215">Eine solche Beschreibung kann dann an die Simulations Bibliothek weitergeleitet werden, um die Zeitentwicklung durch einen Simulations Algorithmus Ihrer Wahl zu implementieren, wobei viele Details automatisch berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="72fb1-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="72fb1-216">Die nachstehend beschriebene Dynamical Generator Library wird in den Beispielen behandelt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="72fb1-217">Ein Beispiel, das auf dem Modell zum Modellieren von Modellen basiert, finden Sie im Beispiel [ **isinggenerators** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span><span class="sxs-lookup"><span data-stu-id="72fb1-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span></span>
> <span data-ttu-id="72fb1-218">Ein Beispiel, das auf Molekular Wasserstoff basiert, finden Sie in den Beispielen [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) und [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) .</span><span class="sxs-lookup"><span data-stu-id="72fb1-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) and [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="72fb1-219">Umfassende Beschreibung eines Generators</span><span class="sxs-lookup"><span data-stu-id="72fb1-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="72fb1-220">Auf der obersten Ebene befindet sich eine komplette Beschreibung eines hamiltonan im `EvolutionGenerator` benutzerdefinierten Typs mit zwei Komponenten:</span><span class="sxs-lookup"><span data-stu-id="72fb1-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="72fb1-221">Der `GeneratorSystem` benutzerdefinierte Typ ist eine klassische Beschreibung der hamiltonan.</span><span class="sxs-lookup"><span data-stu-id="72fb1-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="72fb1-222">Das erste `Int` Element des Tupels speichert die Anzahl der Begriffe $d $ in der hamiltonan, und das zweite Element `(Int -> GeneratorIndex)` ist eine Funktion, die einen ganzzahligen Index in $\{0, 1,..., d-1\}$ einem `GeneratorIndex` benutzerdefinierten Typ zuordnet, der die einzelnen Elemente eindeutig identifiziert. primitiver Begriff in der hamiltonan.</span><span class="sxs-lookup"><span data-stu-id="72fb1-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="72fb1-223">Beachten Sie, dass durch Ausdrücken der Auflistung von Begriffen in der hamiltona als Funktion und nicht als Array `GeneratorIndex[]`eine dynamische Berechnung der `GeneratorIndex` ermöglicht wird. Dies ist besonders nützlich, wenn Sie hamiltonane mit einer großen Anzahl von Begriffen beschreiben.</span><span class="sxs-lookup"><span data-stu-id="72fb1-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="72fb1-224">Entscheidend ist, dass wir keine Konventionen dafür vorsehen, welche primitiven Begriffe, die durch die `GeneratorIndex` identifiziert werden, leicht zu simulieren sind.</span><span class="sxs-lookup"><span data-stu-id="72fb1-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="72fb1-225">Primitive Begriffe können z. b. "Pauli"-Operatoren sein, wie oben erläutert, Sie können jedoch auch eine fermionische Zerstörung und Erstellungs Operatoren sein, die häufig in der Quantum-Chemie Simulation</span><span class="sxs-lookup"><span data-stu-id="72fb1-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="72fb1-226">Eine `GeneratorIndex` ist allein bedeutungslos, da Sie nicht beschreibt, wie die Zeit Weiterentwicklung durch den Begriff, auf den Sie verweist, als Quantum-Leitung implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="72fb1-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="72fb1-227">Dies wird behoben, indem ein `EvolutionSet` benutzerdefinierter Typ angegeben wird, der alle `GeneratorIndex`, die von einer kanonischen Menge gezeichnet werden, einem einheitlichen Operator, dem `EvolutionUnitary`, als Quantum-Verbindung zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="72fb1-228">In der `EvolutionSet` wird die Konvention definiert, wie ein `GeneratorIndex` strukturiert ist, und es wird außerdem der Satz möglicher `GeneratorIndex`definiert.</span><span class="sxs-lookup"><span data-stu-id="72fb1-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="72fb1-229">Pauli-Operator Generatoren</span><span class="sxs-lookup"><span data-stu-id="72fb1-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="72fb1-230">Ein konkretes und nützliches Beispiel für Generatoren ist eine Summe von Pauli-Operatoren, die jeweils über einen anderen Koeffizienten verfügen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="72fb1-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $, wobei jede $ \hat H_j $ nun von der Gruppe "Pauli" gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="72fb1-232">Bei solchen Systemen stellen wir den `PauliEvolutionSet()` vom Typ `EvolutionSet` bereit, der eine Konvention definiert, wie ein Element der Gruppe "Pauli" und ein Koeffizienten durch eine `GeneratorIndex`identifiziert werden können, die über die folgende Signatur verfügt.</span><span class="sxs-lookup"><span data-stu-id="72fb1-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="72fb1-233">In der Codierung gibt der erste Parameter `Int[]` eine Pauli-Zeichenfolge an, wobei $ \hat i\rightarrow $0, $ \hat x\rightarrow $1, $ \hat y\rightarrow $2 und $ \hat z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="72fb1-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="72fb1-234">Der zweite Parameter `Double[]` speichert den Koeffizienten der Pauli-Zeichenfolge in der hamiltonan.</span><span class="sxs-lookup"><span data-stu-id="72fb1-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="72fb1-235">Beachten Sie, dass nur das erste Element dieses Arrays verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="72fb1-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="72fb1-236">Der dritte Parameter `Int[]` indiziert die Qubits, auf die diese Pauli-Zeichenfolge angewendet wird, und darf keine doppelten Elemente aufweisen.</span><span class="sxs-lookup"><span data-stu-id="72fb1-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="72fb1-237">Daher kann der hamiltona-Begriff $0,4 \hat x_0 \hat Y_8\hat I_2\hat Z_1 $ als</span><span class="sxs-lookup"><span data-stu-id="72fb1-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="72fb1-238">Der-`PauliEvolutionSet()` ist eine Funktion, die `GeneratorIndex` dieses Formulars einem `EvolutionUnitary` mit der folgenden Signatur zuordnet.</span><span class="sxs-lookup"><span data-stu-id="72fb1-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="72fb1-239">Der erste Parameter stellt eine Zeitdauer dar, die mit dem Koeffizienten in der `GeneratorIndex`multipliziert wird, der einheitlichen Weiterentwicklung.</span><span class="sxs-lookup"><span data-stu-id="72fb1-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="72fb1-240">Der zweite Parameter ist das Qubit-Register, für das die einheitliche fungiert.</span><span class="sxs-lookup"><span data-stu-id="72fb1-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="72fb1-241">Zeitabhängige Generatoren</span><span class="sxs-lookup"><span data-stu-id="72fb1-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="72fb1-242">In vielen Fällen sind wir auch daran interessiert, zeitabhängige Generatoren zu modellieren. wie bei der Schrödinger-Gleichung $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat h (t) \ket{\psi (t)}, \end{align} $ $, wobei der Generator $ \hat H (t) $ jetzt ist Zeit abhängig.</span><span class="sxs-lookup"><span data-stu-id="72fb1-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="72fb1-243">Die Erweiterung aus den zeitunabhängigen Generatoren oberhalb dieses Falls ist einfach.</span><span class="sxs-lookup"><span data-stu-id="72fb1-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="72fb1-244">Anstatt ein festes `GeneratorSystem` zu haben, das den hamiltona für alle Zeit $t $ beschreibt, haben wir stattdessen den `GeneratorSystemTimeDependent` benutzerdefinierten Typ.</span><span class="sxs-lookup"><span data-stu-id="72fb1-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="72fb1-245">Der erste Parameter ist ein kontinuierlicher Zeit Plan Parameter $s \in [0, 1] $, und Funktionen dieses Typs geben eine `GeneratorSystem` für diesen Zeitplan zurück.</span><span class="sxs-lookup"><span data-stu-id="72fb1-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="72fb1-246">Beachten Sie, dass der Zeit Plan Parameter linear mit dem physischen Zeitparameter verknüpft werden kann, z. b. $s = t/t $, für eine Gesamtzeit der Simulation $T $.</span><span class="sxs-lookup"><span data-stu-id="72fb1-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="72fb1-247">Im Allgemeinen muss dies jedoch nicht der Fall sein.</span><span class="sxs-lookup"><span data-stu-id="72fb1-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="72fb1-248">Entsprechend ist für eine umfassende Beschreibung dieses Generators ein `EvolutionSet`erforderlich. Daher wird ein `EvolutionSchedule` benutzerdefinierter Typ definiert.</span><span class="sxs-lookup"><span data-stu-id="72fb1-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
