---
title: Das Qubit in Quantum Computing
description: Erfahren Sie mehr über Qubits, die grundlegende Einheit der Informationen in Quantum Computing.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
ms.openlocfilehash: 833c9649b7fbcf8b9fde62c37246b9345fe59a92
ms.sourcegitcommit: e23178d32b316d05784a02ba3cd6166dad177e89
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/09/2020
ms.locfileid: "84630353"
---
# <a name="the-qubit"></a><span data-ttu-id="03864-103">Das Qubit</span><span class="sxs-lookup"><span data-stu-id="03864-103">The Qubit</span></span>

<span data-ttu-id="03864-104">Ebenso wie Bits das grundlegende Objekt der Informationen in klassischem Computing sind, sind [*Qubits*](https://en.wikipedia.org/wiki/Qubit) (Quantum Bits) das grundlegende Objekt der Informationen in Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="03864-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="03864-105">Um diese Entsprechung zu verstehen, betrachten wir das einfachste Beispiel: ein einzelnes Qubit.</span><span class="sxs-lookup"><span data-stu-id="03864-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="03864-106">Darstellen eines Qubit</span><span class="sxs-lookup"><span data-stu-id="03864-106">Representing a Qubit</span></span>

<span data-ttu-id="03864-107">Obwohl ein Bit oder eine binäre Ziffer entweder den Wert $0 $ oder $1 haben kann $ , kann ein Qubit über einen Wert verfügen, der entweder eine dieser oder eine Quantum-Superposition von $0 $ und $1 ist $ .</span><span class="sxs-lookup"><span data-stu-id="03864-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="03864-108">Der Zustand eines einzelnen Qubit kann durch einen zweidimensionalen Spalten Vektor der Einheits Norm beschrieben werden, d. h. die Größe des Quadrats der Einträge muss auf $1 summiert werden $ .</span><span class="sxs-lookup"><span data-stu-id="03864-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="03864-109">Dieser Vektor, der als Quantum State Vector bezeichnet wird, enthält alle Informationen, die erforderlich sind, um das One-Qubit-Quantum-System so zu beschreiben, wie ein einzelnes Bit alle Informationen enthält, die erforderlich sind, um den Status einer binären Variablen zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="03864-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="03864-110">Ein zweidimensionaler Spalten Vektor von reellen oder komplexen Zahlen mit Norm $1 $ stellt einen möglichen Quantum-Zustand dar, der von einem Qubit gehalten wird.</span><span class="sxs-lookup"><span data-stu-id="03864-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="03864-111">Daher stellt "$ \begin{ bmatrix } \alpha \\ \\ \beta \ End{ bmatrix } $" einen Qubit-Status dar, wenn "$ \alpha" $ und "$ \beta" $ komplexe Zahlen sind, die "$ | \alpha | ^ 2 + | \beta | ^ 2 = 1" erfüllen $ .</span><span class="sxs-lookup"><span data-stu-id="03864-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="03864-112">Einige Beispiele für gültige Quantum State Vektoren, die Qubits darstellen, sind include</span><span class="sxs-lookup"><span data-stu-id="03864-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="03864-113">$ $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , \begin{ bmatrix } \bruchteil {1 } {\sqrt{2} } \\ \\ \bruchteil {1 } {\sqrt{2 } } \end{ bmatrix } , \begin{ bmatrix } \bruchteil {1 } {\sqrt{2} } \\ \\ \frac { -1 } {\sqrt{2 } } \end{ bmatrix } , \text { und} \begin{ bmatrix } \bruchteil {1 } {\sqrt{2} } \\ \\ \bruchteil {i } {\sqrt{2} } \end{ bmatrix } . $ $</span><span class="sxs-lookup"><span data-stu-id="03864-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="03864-114">Die Quantum State Vektoren $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ und $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $ nehmen eine besondere Rolle auf.</span><span class="sxs-lookup"><span data-stu-id="03864-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="03864-115">Diese beiden Vektoren bilden eine Grundlage für den Vektorraum, der den Qubit-Zustand beschreibt.</span><span class="sxs-lookup"><span data-stu-id="03864-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="03864-116">Dies bedeutet, dass jeder Quanten Zustands Vektor als Summe dieser Basis Vektoren geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="03864-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="03864-117">Insbesondere kann der Vektor $ \begin{ bmatrix } x \\ \\ y \end{ bmatrix } $ als $x \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } + y \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $ geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="03864-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="03864-118">Obwohl jede Drehung dieser Vektoren als vollständig gültige Basis für das Qubit fungieren würde, wählen wir diese Berechtigung aus, indem wir Sie als *Berechnungsgrundlage*aufrufen.</span><span class="sxs-lookup"><span data-stu-id="03864-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="03864-119">Wir verwenden diese beiden Quantum-Zustände, damit Sie den zwei Zuständen eines klassischen Bits entsprechen, nämlich $0 $ und $1 $ .</span><span class="sxs-lookup"><span data-stu-id="03864-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="03864-120">Die Standard Konvention besteht darin,</span><span class="sxs-lookup"><span data-stu-id="03864-120">The standard convention is to choose</span></span>

<span data-ttu-id="03864-121">$ $0 \equiv \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \qquad 1 \equiv \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , $ $</span><span class="sxs-lookup"><span data-stu-id="03864-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="03864-122">Obwohl die entgegengesetzte Auswahl gleichermaßen gut wäre.</span><span class="sxs-lookup"><span data-stu-id="03864-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="03864-123">Folglich entsprechen nur zwei der unendlichen Zahl der möglichen Single-Qubit Quantum State Vectors den Zuständen klassischer Bits. nicht alle anderen Quantum-Zustände.</span><span class="sxs-lookup"><span data-stu-id="03864-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="03864-124">Messen eines Qubit</span><span class="sxs-lookup"><span data-stu-id="03864-124">Measuring a Qubit</span></span>

<span data-ttu-id="03864-125">Nachdem wir nun wissen, wie Sie ein Qubit darstellen, können wir eine gewisse intuitions Bedeutung für diese Zustände erzielen, indem wir das Konzept der [*Messung*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics)erörtern.</span><span class="sxs-lookup"><span data-stu-id="03864-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="03864-126">Eine Maßeinheit entspricht dem informellen Konzept der "Betrachtung" bei einem Qubit, das den Zustand des Quantums sofort auf einen der beiden klassischen Zustände "$ \begin{ bmatrix } 1 \\ \\ 0 \ End{ bmatrix } $" oder "$ \begin{ bmatrix } 0 \\ \\ 1 \ End{ bmatrix } $" reduziert.</span><span class="sxs-lookup"><span data-stu-id="03864-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="03864-127">Wenn ein vom quantenvektor $ \begin{ bmatrix } \alpha \\ \\ \beta \end{$ angegebener Qubit bmatrix } gemessen wird, wird das Ergebnis $0 $ mit der Wahrscheinlichkeit $ | \alpha | ^ 2 $ und das Ergebnis $1 $ mit der Wahrscheinlichkeit $ | \beta | ^ 2 abgerufen $ .</span><span class="sxs-lookup"><span data-stu-id="03864-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="03864-128">Bei Ergebnis $0 $ lautet der neue Status des Qubits "$ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $;" im Ergebnis $1 der $ Status ist "$ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $".</span><span class="sxs-lookup"><span data-stu-id="03864-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="03864-129">Beachten Sie, dass diese Wahrscheinlichkeiten aufgrund der $ normalisierungs Bedingung $ | \alpha | ^ 2 + | \beta | ^ 2 = 1 summiert $1 werden $ .</span><span class="sxs-lookup"><span data-stu-id="03864-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="03864-130">Die Eigenschaften der Messung bedeuten auch, dass das Gesamt Vorzeichen des quantenvektoren irrelevant ist.</span><span class="sxs-lookup"><span data-stu-id="03864-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="03864-131">Das neinieren eines Vektors entspricht "$ \alpha \rightarrow-\alpha" $ und "$ \beta \rightarrow-\beta" $ .</span><span class="sxs-lookup"><span data-stu-id="03864-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="03864-132">Da die Wahrscheinlichkeit $ , $0 und $1 $ zu messen, von der Größenordnung der Bedingungen abhängt, ändert das Einfügen dieser Zeichen nicht die Wahrscheinlichkeiten.</span><span class="sxs-lookup"><span data-stu-id="03864-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="03864-133">Solche Phasen werden in der Regel als [ \`\` *globale Phasen*""](https://en.wikipedia.org/wiki/Phase_factor) bezeichnet, und in der Regel können Sie die Form $e ^ {i \phi } $ anstelle von "$ \pm 1" haben $ .</span><span class="sxs-lookup"><span data-stu-id="03864-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="03864-134">Eine letzte wichtige Eigenschaft der Messung ist, dass Sie nicht notwendigerweise alle quantenvektoren beschädigt.</span><span class="sxs-lookup"><span data-stu-id="03864-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="03864-135">Wenn wir mit einem Qubit im Status $ \begin{ bmatrix } 1 \\ \\ 0 \ End{$ beginnen bmatrix } , was dem klassischen Zustand $0 entspricht $ , ergibt das Messen dieses Zustands immer das Ergebnis $0 $ und lässt den Quantenzustand unverändert.</span><span class="sxs-lookup"><span data-stu-id="03864-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="03864-136">Wenn nur klassische Bits vorhanden sind (d. h. Qubits, die entweder $ \begin{ bmatrix } 1 \\ \\ 0 \ End{ bmatrix } $ oder $ \begin{ bmatrix } 0 \\ \\ 1 \ End{ bmatrix } $ lauten), wird das System durch die Messung nicht beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="03864-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="03864-137">Dies bedeutet, dass wir klassische Daten replizieren und auf einem Quantum-Computer genauso wie auf einem klassischen Computer bearbeiten können.</span><span class="sxs-lookup"><span data-stu-id="03864-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="03864-138">Die Möglichkeit, Informationen in beiden Zuständen gleichzeitig zu speichern, liegt jedoch in der herauf Setzung von Quantum Computing über das, was klassisch ist, und den weiteren Quantum-Computern, die die Möglichkeit haben, Quantum-Daten zu kopieren, auch [das No-Klon-Theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="03864-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="03864-139">Visualisieren von Qubits und Transformationen mithilfe der Bloch-Kugel</span><span class="sxs-lookup"><span data-stu-id="03864-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="03864-140">Qubits können auch in "$ 3 $ D" mithilfe der [*Bloch Sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) -Darstellung dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="03864-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="03864-141">Die Bloch-Kugel bietet eine Möglichkeit zum Beschreiben eines Single-Qubit-Quantum-Zustands (bei dem es sich um einen zweidimensionalen komplexen Vektor handelt) als dreidimensionaler echt Wert Vektor.</span><span class="sxs-lookup"><span data-stu-id="03864-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="03864-142">Dies ist wichtig, da es uns ermöglicht, Single-Qubit-Zustände visuell darzustellen und auf diese Weise Argumente zu entwickeln, die für das Verständnis von multiqubit-Zuständen von Bedeutung sein können</span><span class="sxs-lookup"><span data-stu-id="03864-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="03864-143">Die Bloch-Kugel kann wie folgt visualisiert werden:</span><span class="sxs-lookup"><span data-stu-id="03864-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="03864-144">![Bloch-Kugel](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="03864-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="03864-145">Die Pfeile in diesem Diagramm zeigen die Richtung an, in der der Quantum-Status Vektor zeigt, und jede Transformation des Pfeils kann als Drehung zu einer der Hauptachsen betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="03864-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="03864-146">Obwohl eine Quantum-Berechnung als Folge von Rotationen eine leistungsstarke Intuition darstellt, ist es schwierig, diese intuienz zu verwenden, um Algorithmen zu entwerfen und zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="03864-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="03864-147">F # verringert dieses Problem, indem es eine Sprache zum beschreiben solcher Drehungen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="03864-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="03864-148">Single-Qubit-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="03864-148">Single-Qubit Operations</span></span>

<span data-ttu-id="03864-149">Quantum-Computer verarbeiten Daten, indem Sie einen universellen Satz von Quantum-Gates anwenden, mit dem jede Drehung des quantalen Zustands Vektors emuliert werden kann.</span><span class="sxs-lookup"><span data-stu-id="03864-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="03864-150">Dieses Konzept der Universalität ähnelt dem Konzept der Universalität für traditionelles (d.h. klassisches) Computing, bei dem ein Gate-Satz als universell betrachtet wird, wenn jede Transformation der Eingabe Bits mithilfe einer begrenzten Längen Verbindung ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="03864-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="03864-151">Bei der Quantenberechnung sind die gültigen Transformationen, die wir für ein Qubit ausführen dürfen, einheitliche Transformationen und Messungen.</span><span class="sxs-lookup"><span data-stu-id="03864-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="03864-152">Der *Adjoint-Vorgang* oder das komplexe konjugierte austauschen ist für das Quantum Computing von entscheidender Bedeutung, da es für das Umkehren von Quantum-Transformationen erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="03864-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="03864-153">F # reflektiert dies durch die Bereitstellung von Methoden zum automatischen Kompilieren von Gate-Sequenzen in ihren Adjoint-Code, der es dem Programmierer erspart, Code-adjoints in vielen Fällen zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="03864-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="03864-154">Ein Beispiel hierfür finden Sie unten:</span><span class="sxs-lookup"><span data-stu-id="03864-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="03864-155">Obwohl es sich hierbei um ein sehr einfaches Beispiel handelt (da der <xref:microsoft.quantum.intrinsic.h> ) Vorgang selbst Adjoint ist), können Sie sehen, wie dies für kompliziertere Qubit-Vorgänge von Bedeutung wird.</span><span class="sxs-lookup"><span data-stu-id="03864-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h[!OP.NO-LOC(> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="03864-156">Weitere Informationen finden Sie unter [Vorgänge und Funktionen](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="03864-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="03864-157">Es gibt nur vier Funktionen, die einem Bit auf einem klassischen Computer ein Bit zuordnen.</span><span class="sxs-lookup"><span data-stu-id="03864-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="03864-158">Im Gegensatz dazu gibt es eine unendliche Anzahl einheitlicher Transformationen auf einem einzigen Qubit auf einem Quantum-Computer.</span><span class="sxs-lookup"><span data-stu-id="03864-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="03864-159">Daher kann kein endlicher Satz primitiver Quantum-Vorgänge, sogenannte [*Gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), den unendlichen Satz einheitlicher Transformationen, die in Quantum Computing zulässig sind, exakt replizieren.</span><span class="sxs-lookup"><span data-stu-id="03864-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="03864-160">Dies bedeutet, dass es im Gegensatz zu klassischem Computing nicht möglich ist, dass ein Quantum-Computer jedes mögliche Quantum-Programm genau mit einer begrenzten Anzahl von Gates implementiert.</span><span class="sxs-lookup"><span data-stu-id="03864-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="03864-161">Daher können Quantum-Computer nicht im gleichen Sinne von klassischen Computern universell sein.</span><span class="sxs-lookup"><span data-stu-id="03864-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="03864-162">Wenn wir sagen, dass ein Satz von Gates für das Quantum Computing *universell* ist, bedeutet dies, dass etwas schwächer ist als bei klassischem Computing.</span><span class="sxs-lookup"><span data-stu-id="03864-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="03864-163">Bei der Universalität ist es erforderlich, dass ein Quantum-Computer *nur jede einheitliche* Matrix innerhalb eines begrenzten Fehlers mithilfe einer endlichen Längen Gate-Sequenz anfordert.</span><span class="sxs-lookup"><span data-stu-id="03864-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="03864-164">Anders ausgedrückt: ein Satz von Gates ist ein universelles Gate, wenn eine einheitliche Transformation ungefähr als ein Produkt von Gates aus dieser Menge geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="03864-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="03864-165">Wir verlangen, dass für jede vorgeschriebene Fehlergrenze Gates $G _ {1 } , g_ {2 } , \ldots G_N $ aus dem Gate-Satz vorhanden ist, sodass</span><span class="sxs-lookup"><span data-stu-id="03864-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="03864-166">$ $ G_N g_ {N-1 } \cdots G_2 G_1 \ca. $ $</span><span class="sxs-lookup"><span data-stu-id="03864-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="03864-167">Beachten Sie Folgendes: da die Konvention für die Matrix Multiplikation von rechts nach links multipliziert werden muss, ist der erste Gate-Vorgang in dieser Sequenz, $G _N $ , tatsächlich der letzte, der auf den Quantum-Status Vektor angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="03864-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="03864-168">Formal gesagt, dass ein solcher Gate-Satz universell ist, wenn für jede Fehlertoleranz $ \epsilon>0 $ vorhanden ist $G _1, \ldots, G_N, $ sodass der Abstand zwischen $G _N \ldots G_1 $ und $U höchstens $ $ \epsilon liegt $ .</span><span class="sxs-lookup"><span data-stu-id="03864-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="03864-169">Im Idealfall sollte der Wert $N $ , der für diese Entfernung von $ \epsilon erforderlich ist, $ polylogarithmisch mit $1/\ Epsilon skalieren $ .</span><span class="sxs-lookup"><span data-stu-id="03864-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="03864-170">Wie sieht eine solche universelle Gate-Menge in der Praxis aus?</span><span class="sxs-lookup"><span data-stu-id="03864-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="03864-171">Das einfachste solche universelle Gate für Single-Qubit-Gates besteht nur aus zwei Gates: dem Hadamard-Gate $H $ und dem sogenannten $T $ Gate (auch als "$ \ PI/8 Gate" bezeichnet $ ):</span><span class="sxs-lookup"><span data-stu-id="03864-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="03864-172">$ $ H = \bruchteil {1 } {\sqrt{2} } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad T = \begin{ bmatrix } 1 & 0 \\ \\ 0 & e ^ {i \ pi/4 } \end{ bmatrix } .</span><span class="sxs-lookup"><span data-stu-id="03864-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="03864-173">Aus praktischen Gründen im Zusammenhang mit der Quantum-Fehlerkorrektur kann es jedoch bequemer sein, einen größeren Gate-Satz in Erwägung zu nehmen, nämlich einen, der mit $H und $T generiert werden kann $ $ .</span><span class="sxs-lookup"><span data-stu-id="03864-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="03864-174">Wir können die Quantum-Gates in zwei Kategorien klassifizieren: Clifford Gates und das $T $ Gate.</span><span class="sxs-lookup"><span data-stu-id="03864-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="03864-175">Diese Unterteilung ist nützlich, da die so genannten Clifford-Gates in vielen Quantum-Fehlerkorrekturen leicht implementiert werden können, sodass Sie nur wenige Ressourcen in Bezug auf Vorgänge und Qubits benötigen, um fehlertolerant zu implementieren, während nicht-Clifford Gates bei der Verwendung von Fehlertoleranz recht kostspielig sind.</span><span class="sxs-lookup"><span data-stu-id="03864-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="03864-176">Der Standardsatz von Single-Qubit Clifford Gates, der [standardmäßig in Q # enthalten](xref:microsoft.quantum.libraries.standard.prelude)ist, umfasst</span><span class="sxs-lookup"><span data-stu-id="03864-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="03864-177">$ $ H = \bruchteil {1 } {\sqrt{2} } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad S = \begin{ bmatrix } 1 & 0 \\ \\ 0 & i \end{ bmatrix } = T ^ 2, \qquad X = \begin{ bmatrix } 0 #b4 1 \\ \\ 1 & 0 \end{ bmatrix } = HT ^ 4H, $ $</span><span class="sxs-lookup"><span data-stu-id="03864-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="03864-178">$ $ Y = \begin{ bmatrix } 0 &-i \\ \\ i & 0 \end{ bmatrix } = t ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{ bmatrix } 1&0 \\\\ 0 & -1 \end{ bmatrix } = t ^ 4.</span><span class="sxs-lookup"><span data-stu-id="03864-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="03864-179">Hier werden die Vorgänge $X $ , $Y $ und $Z $ vor allem häufig verwendet und nach dem Ersteller Wolfgang Pauli als Pauli- [*Operatoren*](https://en.wikipedia.org/wiki/Pauli_matrices) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="03864-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="03864-180">Zusammen mit dem nicht-Clifford-Gate (der $T $ -Gate) können diese Vorgänge so zusammengesetzt werden, dass jede einheitliche Transformation in einem einzelnen Qubit einander entspricht.</span><span class="sxs-lookup"><span data-stu-id="03864-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="03864-181">Weitere Informationen zu diesen Vorgängen, ihren Bloch Sphere-Darstellungen und f #-Implementierungen finden Sie unter systeminterne [Vorgänge und Funktionen](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="03864-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="03864-182">Als Beispiel dafür, wie einheitliche Transformationen aus diesen primitiven erstellt werden können, entsprechen die drei Transformationen, die in den Bloch-Bereichen oben dargestellt werden, der Gate-Sequenz $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } \mapsto hzh \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } = \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="03864-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="03864-183">Während die vorherige die beliebtesten primitiven Gates zum Beschreiben von Vorgängen auf der logischen Ebene des Stapels bilden (denken Sie an die logische Ebene als die Ebene des Quantum-Algorithmus), ist es häufig sinnvoll, weniger grundlegende Vorgänge auf algorithmische Ebene zu berücksichtigen, z. b. Vorgänge, die näher an einer Funktions Beschreibungs Ebene liegen.</span><span class="sxs-lookup"><span data-stu-id="03864-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="03864-184">Glücklicherweise verfügt Q # auch über Methoden, die für die Implementierung von unidirektionalbasierten uniflüssen verfügbar sind, die wiederum die Implementierung von Algorithmen auf hoher Ebene ermöglichen, ohne alle Elemente explizit in Clifford und $T Gates zu zerlegen $ .</span><span class="sxs-lookup"><span data-stu-id="03864-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="03864-185">Die einfachste solche primitive ist die einzelne Qubit-Rotation.</span><span class="sxs-lookup"><span data-stu-id="03864-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="03864-186">In der Regel werden drei Single-Qubit-Drehungen berücksichtigt: $R _x $ , $R _y $ und $R _Z $ .</span><span class="sxs-lookup"><span data-stu-id="03864-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="03864-187">Um die Aktion der Drehung $R _x (\urta) zu visualisieren, zeigen Sie z. b. an, dass der Ziehpunkt auf die Richtung der $x $ Achse der Bloch-Kugel zeigt, und drehen Sie den Vektor mit der Hand durch einen Winkel von $ \ der TA/2 $ radiane.</span><span class="sxs-lookup"><span data-stu-id="03864-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="03864-188">Dieser verwirrende Faktor von $2 $ ergibt sich aus der Tatsache, dass orthogonale Vektoren $180 ^ \circ $ voneinander entfernt sind, wenn Sie in der Bloch-Kugel gezeichnet werden, aber tatsächlich gleich $90 ^ \circ $ Grad gleichmäßig sind.</span><span class="sxs-lookup"><span data-stu-id="03864-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="03864-189">Die entsprechenden einheitlichen Matrizen lauten:</span><span class="sxs-lookup"><span data-stu-id="03864-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="03864-190">\begin{align *} &R_z (\orta) = e ^ {-i\der Ta z/2 } = \begin{ bmatrix } e ^ {-i \ der TA/2 } & 0 \\\\ 0 & e ^ {i \ der TA/2 } \ End{ bmatrix } , \\ \\ &R_x (\urta) = e ^ {-i\theita x/2 } = HR_z (\orta) H = \begin{ bmatrix } \cos (\ der TA/2) &-i\sin (\ der TA/2) \\ \\ -i\sin (\ der TA/2) & \cos (\-Ta/2) \end{ bmatrix } , \\ \\ &R_y (\orta) = e ^ {-i\der ta y/2 } = SHR_z (\orta) HS ^ \dagger = \begin{ bmatrix } \cos (\ der TA/2) &-\sin (\ der TA/2) \\ \\ \sin (\ der TA/2) & \cos (\ der TA/2) \end{ bmatrix } . \end{align*}</span><span class="sxs-lookup"><span data-stu-id="03864-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="03864-191">Ebenso wie jede beliebige drei Drehung kombiniert werden kann, um eine willkürliche Drehung in drei Dimensionen auszuführen, kann Sie aus der Bloch Sphere-Darstellung ersichtlich werden, dass jede einheitliche Matrix auch als Sequenz von drei Umdrehungen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="03864-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="03864-192">Insbesondere für jede einheitliche Matrix $U vorhanden ist $ $ \alpha, \beta, \gamma, \delta, $ sodass $U = e ^ {i \alpha } R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="03864-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="03864-193">Daher $R _Z (\teta) $ und $H $ auch einen universellen Gate-Satz bilden, obwohl es sich nicht um einen diskreten Satz handelt, da $ $ \teta einen beliebigen Wert annehmen kann.</span><span class="sxs-lookup"><span data-stu-id="03864-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="03864-194">Aus diesem Grund und aufgrund von Anwendungen in der Quantum-Simulation sind solche kontinuierlichen Gates für die Quantum-Berechnung wichtig, insbesondere auf der Entwurfs Ebene des Quantum-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="03864-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="03864-195">Um eine fehlertolerante Hardware Implementierung zu erreichen, werden Sie letztendlich in diskrete Gate-Sequenzen kompiliert, die diesen Rotationen sehr ähnlich sind.</span><span class="sxs-lookup"><span data-stu-id="03864-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
