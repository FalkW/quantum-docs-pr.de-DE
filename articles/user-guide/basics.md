---
title: 'F #-Grundlagen'
description: 'Grundlegende Konzepte von Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: fd0ea47f00b1456ec460808ef7d451c8427677cd
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431154"
---
# <a name="q-basics"></a><span data-ttu-id="a5bb6-103">F #-Grundlagen</span><span class="sxs-lookup"><span data-stu-id="a5bb6-103">Q# Basics</span></span>

<span data-ttu-id="a5bb6-104">In diesem Abschnitt wird eine kurze Einführung in die grundlegenden Bausteine von Q # vorgestellt.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="a5bb6-105">Eine kurze Übersicht darüber, was q # ist und wo es als grundlegende Komponente des Quantum Development Kit passt, finden Sie unter [Was ist q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="a5bb6-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="a5bb6-106">Was ist ein Quantum-Programm?</span><span class="sxs-lookup"><span data-stu-id="a5bb6-106">What is a quantum program?</span></span>

<span data-ttu-id="a5bb6-107">Aus technischer Sicht kann ein Quantum-Programm als ein bestimmter Satz klassischer Unterroutinen angesehen werden, die beim Aufruf bestimmte Vorgänge auf einem Quantum-System ausführen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="a5bb6-108">Eine wichtige Konsequenz dieser Ansicht besteht darin, dass ein in Q # geschriebenes Programm Qubits selbst nicht direkt modelliert, sondern vielmehr beschreibt, wie ein klassischer Steuerungscomputer mit diesen Qubits interagiert.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="a5bb6-109">Entwurfs bedingt definiert f # daher nicht die Quantum-Zustände oder andere Eigenschaften von Quantum-Mechanismen direkt.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="a5bb6-110">Sehen Sie sich beispielsweise den Status $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ an, der im Handbuch für die [Quantum Computing-Konzepte](xref:microsoft.quantum.concepts.intro) erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="a5bb6-111">Um diesen Status in Q # vorzubereiten, verwenden wir die Fakten, die die Qubits im Zustand "$ \ket $" initialisiert werden {0} , und "$ \ket{+} = h\ket {0} $", wobei "$H $" die durch [ `H` Operation] (] (Xref: Microsoft. Quantum. intrinsid. H) implementierte Hadamard-Transformation ist:</span><span class="sxs-lookup"><span data-stu-id="a5bb6-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="a5bb6-112">Quantum-Zustände in Q #</span><span class="sxs-lookup"><span data-stu-id="a5bb6-112">Quantum states in Q#</span></span>

<span data-ttu-id="a5bb6-113">Wichtig: beim Schreiben des obigen Programms haben wir nicht explizit auf den Bundesstaat in Q # verwiesen, sondern vielmehr beschrieben, wie der Zustand von unserem Programm *transformiert* wurde.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="a5bb6-114">Dies ermöglicht es uns, unabhängig davon, was ein Quantum-Status *ist* , auch auf jedem Zielcomputer zu sein, der je nach Computer unterschiedliche Interpretationen aufweisen kann.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="a5bb6-115">Ein Q #-Programm hat keine Möglichkeit, den Zustand eines Qubit zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="a5bb6-116">Stattdessen kann ein Programm Vorgänge wie z. b. [`Measure`](xref:microsoft.quantum.intrinsic.measure) zum Erlernen von Informationen aus einem Qubit und zum Abrufen von Vorgängen wie [`X`](xref:microsoft.quantum.intrinsic.x) und [`H`](xref:microsoft.quantum.intrinsic.h) zum reagieren auf den Zustand eines Qubits aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="a5bb6-117">Diese Vorgänge *werden tatsächlich nur* vom Zielcomputer durchgeführt, mit dem das jeweilige Q #-Programm ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="a5bb6-118">Wenn Sie das Programm z. b. in unserem [vollständigen Simulator](xref:microsoft.quantum.machines.full-state-simulator)ausführen, führt der Simulator die entsprechenden mathematischen Operationen für das simulierte Quantum-System aus.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="a5bb6-119">Wenn der Zielcomputer jedoch ein echter Quantum-Computer ist, wird der Quantum-Computer durch das aufrufen solcher Vorgänge in Q # an die Zukunft weitergeleitet, um die entsprechenden *echten* Vorgänge auf dem *realen* Quantum-System auszuführen (z. b. genau zeitgesteuerte Laserpulse).</span><span class="sxs-lookup"><span data-stu-id="a5bb6-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="a5bb6-120">Ein Q #-Programm kombiniert diese Vorgänge neu, wie von einem Zielcomputer definiert, um neue Vorgänge auf höherer Ebene zu erstellen, um die Quantum-Berechnung auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="a5bb6-121">Auf diese Weise vereinfacht f # das Ausdrücken der Logik zugrunde liegenden Quantum-und Hybrid-Quantum – klassische Algorithmen und ist gleichzeitig in Bezug auf die Struktur eines Ziel Computers oder Simulators allgemein.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="a5bb6-122">F #-Vorgänge und-Funktionen</span><span class="sxs-lookup"><span data-stu-id="a5bb6-122">Q# operations and functions</span></span>

<span data-ttu-id="a5bb6-123">Konkret besteht ein Q #-Programm aus *Vorgängen*, *Funktionen*und benutzerdefinierten Typen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="a5bb6-124">Vorgänge werden verwendet, um die Transformationen von Quantum-Systemen zu beschreiben, und sind die grundlegendsten Bausteine von Q #-Programmen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="a5bb6-125">Jeder in Q # definierte Vorgang kann dann eine beliebige Anzahl anderer Vorgänge aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="a5bb6-126">Im Gegensatz zu Vorgängen werden Funktionen verwendet, um reines *deterministisches* klassisches Verhalten zu beschreiben, und Sie haben keine Auswirkungen, außer wenn Sie klassische Werte berechnen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="a5bb6-127">Angenommen, wir möchten unsere Qubits am Ende eines Programms messen und die Messergebnisse einem Array hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="a5bb6-128">In diesem Fall `Measure` ist ein *Vorgang* , der den Zielcomputer anweist, eine Messung der (realen oder simulierten) Qubits durchzuführen, und der klassische Prozess des Hinzufügens der zurückgegebenen Ergebnisse zu einem Array wird von *Functions*behandelt.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="a5bb6-129">Vorgänge und Funktionen werden als *callables*bezeichnet, und die zugrunde liegende Struktur und das zugehörige Verhalten werden auf der Seite " [Vorgänge und Funktionen" in der f #](xref:microsoft.quantum.guide.operationsfunctions) -Seite eingeführt.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="a5bb6-130">Übersicht über die Q #-Syntax</span><span class="sxs-lookup"><span data-stu-id="a5bb6-130">Q# syntax overview</span></span>

<span data-ttu-id="a5bb6-131">Die Syntax einer Sprache beschreibt die verschiedenen Kombinationen von Symbolen, die ein syntaktisch korrektes Programm bilden.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="a5bb6-132">In Q # können wir die Elemente der Syntax in drei verschiedenen Gruppen klassifizieren: Typen, Ausdrücke und Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="a5bb6-133">Typen</span><span class="sxs-lookup"><span data-stu-id="a5bb6-133">Types</span></span>
<span data-ttu-id="a5bb6-134">F # ist eine stark typisierte Sprache, sodass der Compiler durch die sorgfältige Verwendung von Typen bei der Kompilierung starke Garantien für Q #-Programme bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="a5bb6-135">Zusätzlich zu den standardmäßigen und Quantum-spezifischen, integrierten primitiven Typen (z. b.,, `Int` `Bool` `Qubit` und `Result` ) bietet Q # Unterstützung für benutzerdefinierte Typen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="a5bb6-136">Alle verschiedenen primitiven Typen von q # werden auf der Seite [Typen in q #](xref:microsoft.quantum.guide.types) sowie Details zu Array-und Tupeltypen beschrieben. Außerdem wird erläutert, wie Sie neue Typen in einer q #-Datei definieren.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="a5bb6-137">Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="a5bb6-137">Expressions</span></span>
<span data-ttu-id="a5bb6-138">Ein Ausdruck in einer Programmiersprache ist eine Kombination aus einer oder mehreren Konstanten, Variablen, Operatoren und Funktionen, die von der Programmiersprache interpretiert und zu einem bestimmten Wert ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="a5bb6-139">In den meisten Fällen können Ausdrücke dieses Typs für jeden Typ in einer Sprache entweder *Literale* oder Symbole sein, die an einen Wert dieses Typs gebunden sind.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="a5bb6-140">Beispielsweise `5` ist ein `Int` Literalzeichen (also auch ein Ausdruck vom Typ `Int` ), und wenn das Symbol `count` an den ganzzahligen Wert gebunden ist `5` , dann `count` ist auch ein ganzzahliger Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="a5bb6-141">Außerdem kann ein Ausdruck aus anderen Ausdrücken bestehen, die mit bestimmten Operatoren kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="a5bb6-142">Ein weiteres Beispiel für einen `Int` Ausdruck, der ergibt, `5` ist `2+3` .</span><span class="sxs-lookup"><span data-stu-id="a5bb6-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="a5bb6-143">Die möglichen Ausdrücke von Typen in q # sowie die kompatiblen Operatoren, die verwendet werden können, werden auf den [Typausdrücken in der f #](xref:microsoft.quantum.guide.expressions) -Seite ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="a5bb6-144">Anweisungen</span><span class="sxs-lookup"><span data-stu-id="a5bb6-144">Statements</span></span> 
<span data-ttu-id="a5bb6-145">Eine-Anweisung ist eine syntaktische Einheit einer imperativen Programmiersprache, die eine auszuführende Aktion ausdrückt. -Anweisungen vergleichen mit Ausdrücken in, dass-Anweisungen keine Ergebnisse zurückgeben und ausschließlich für Ihre Nebeneffekte ausgeführt werden, während Ausdrücke immer ein Ergebnis zurückgeben und oft keine Nebeneffekte haben.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="a5bb6-146">Dieser Unterschied wird häufig in einem Wortlaut beobachtet: ein Ausdruck wird ausgewertet, während eine-Anweisung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="a5bb6-147">Ein sehr einfaches Beispiel für eine-Anweisung in Q # ist das Zuweisen eines Symbols zu einem Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="a5bb6-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="a5bb6-148">Ein etwas interessanteres Beispiel ist die `for` -Anweisung, die Iterationen unterstützt und einen- *Anweisungsblock*enthält.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="a5bb6-149">Angenommen `qubits` ist das Symbol, das an ein Register von Qubits gebunden ist (technisch gesehen vom Typ `Qubit[]` , d. h. ein Array von `Qubit` Typen).</span><span class="sxs-lookup"><span data-stu-id="a5bb6-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="a5bb6-150">Then</span><span class="sxs-lookup"><span data-stu-id="a5bb6-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="a5bb6-151">ist eine-Anweisung, die jedes Qubit im Register durchläuft, wobei jeweils der-Vorgang ausgeführt wird `H` .</span><span class="sxs-lookup"><span data-stu-id="a5bb6-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="a5bb6-152">Beachten Sie, dass `H(qubit);` auch eine-Anweisung in sich selbst ist.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="a5bb6-153">Tatsächlich können alle Aufruf Ausdrücke vom Typ (die Aufruf baren Objekte `Unit` , die keine Informationen zurückgeben) als Anweisung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="a5bb6-154">Dies wird hauptsächlich beim Aufrufen von Vorgängen für Qubits verwendet, die zurückgeben, da der Zweck der- `Unit` Anweisung darin besteht, den impliziten Quantum-Zustand zu ändern.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="a5bb6-155">Ausdrucks Auswertungs Anweisungen erfordern ein abschließendes Semikolon.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="a5bb6-156">Fast jeder Aspekt eines Q #-Programms wird mithilfe von-Anweisungen erstellt, sodass keine einzelne Seite alle Informationen im Zusammenhang mit diesen Informationen umfassen kann.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="a5bb6-157">Die lexikalische Struktur und die Formatierung werden jedoch auf der Seite " [f #-Dateistruktur](xref:microsoft.quantum.guide.filestructure) ", der Symbol Bindungs Zuweisung und dem Bereich unter [Variablen in q #](xref:microsoft.quantum.guide.variables)und Ablauf Steuerungs Schleifen, wie z `for` . b. der [Ablauf Steuerung in q #](xref:microsoft.quantum.guide.controlflow), beschrieben.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>


## <a name="whats-next"></a><span data-ttu-id="a5bb6-158">Ausblick</span><span class="sxs-lookup"><span data-stu-id="a5bb6-158">What's next?</span></span>
<span data-ttu-id="a5bb6-159">Im weiteren Verlauf dieses Handbuchs erfahren Sie, wie Sie mit Q # komplexe Quantum-Programme über die grundlegenden Bausteine von Vorgängen, Funktionen und Typen erstellen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="a5bb6-160">Um zu beginnen, können Sie mit dem Kennenlernen von [Typen in f #](xref:microsoft.quantum.guide.types)beginnen.</span><span class="sxs-lookup"><span data-stu-id="a5bb6-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="a5bb6-161">Wenn Sie mehr über die Grundlagen und die Motivation hinter q # erfahren möchten, finden Sie weitere Informationen unter [Warum benötigen wir q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="a5bb6-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
