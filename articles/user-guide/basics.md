---
title: Q# Kenntnisse
description: Grundlegende Konzepte von Q#
author: gillenhaalb
ms.author: a-gibec
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- Q#
- $$v
ms.openlocfilehash: 86f6538cf383f4e7c14255b38cfb1c141c8f991b
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835518"
---
# <a name="no-locq-basics"></a><span data-ttu-id="27364-103">Q# Kenntnisse</span><span class="sxs-lookup"><span data-stu-id="27364-103">Q# Basics</span></span>

<span data-ttu-id="27364-104">Dieser Artikel bietet eine kurze Einführung in die grundlegenden Bausteine von Q# .</span><span class="sxs-lookup"><span data-stu-id="27364-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="27364-105">Einen Überblick darüber, was Q# und wo es als grundlegende Komponente des Quantum Development Kit passt, finden Sie unter [Was ist Q# ?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="27364-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="27364-106">Was ist ein Quantum-Programm?</span><span class="sxs-lookup"><span data-stu-id="27364-106">What is a quantum program?</span></span>

<span data-ttu-id="27364-107">Aus technischer Sicht handelt es sich bei einem Quantum-Programm um einen bestimmten Satz klassischer Unterroutinen, die, wenn Sie aufgerufen werden, bestimmte Vorgänge auf einem Quantum-System ausführen.</span><span class="sxs-lookup"><span data-stu-id="27364-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="27364-108">Eine wichtige Konsequenz dieser Ansicht besteht darin, dass ein Q# Programm Qubits nicht direkt modelliert, sondern vielmehr beschreibt, wie ein klassisch kontrollierter Computer mit diesen Qubits interagiert.</span><span class="sxs-lookup"><span data-stu-id="27364-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="27364-109">Entwurfs bedingt Q# definiert keine Quantenzustände oder anderen Eigenschaften von Quantum-Mechanismen direkt.</span><span class="sxs-lookup"><span data-stu-id="27364-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="27364-110">Sehen Sie sich beispielsweise den Status $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ an, der im Handbuch für die [Quantum Computing-Konzepte](xref:microsoft.quantum.concepts.intro) erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="27364-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="27364-111">Wenn Sie diesen Status in vorbereiten möchten Q# , beginnen Sie mit den Fakten, die die Qubits im Zustand "$ \ket $" initialisiert werden {0} , und "$ \ket{+} = h\ket {0} $", wobei $H $ die vom [ `H` Vorgang](xref:microsoft.quantum.intrinsic.h)implementierte [Hadamard-Transformation](xref:microsoft.quantum.glossary#hadamard)ist.</span><span class="sxs-lookup"><span data-stu-id="27364-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="27364-112">Der grundlegende Q# Code zum Initialisieren und Transformieren eines Qubit sieht dann wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="27364-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="27364-113">Weitere Informationen zum Initialisieren oder *zuordnen*von Qubits finden Sie unter [Arbeiten mit Qubits](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="27364-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-no-locq"></a><span data-ttu-id="27364-114">Quantum-Zustände in Q#</span><span class="sxs-lookup"><span data-stu-id="27364-114">Quantum states in Q#</span></span>

<span data-ttu-id="27364-115">Wichtig ist, dass das vorherige Programm nicht explizit auf den Bundesstaat verweist, Q# sondern beschreibt, wie das Programm den Zustand *transformiert* hat.</span><span class="sxs-lookup"><span data-stu-id="27364-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="27364-116">Bei dieser Vorgehensweise können Sie unabhängig davon, was ein Quantum-Status *ist* , auf jedem Zielcomputer, der je nach Computer unterschiedliche Interpretationen aufweisen kann, vollständig agnostisch sein.</span><span class="sxs-lookup"><span data-stu-id="27364-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="27364-117">Ein Q# Programm kann nicht in den Zustand eines Qubit-Felds hinein geraten.</span><span class="sxs-lookup"><span data-stu-id="27364-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="27364-118">Stattdessen kann ein Programm Vorgänge wie z. b. [`Measure`](xref:microsoft.quantum.intrinsic.measure) zum Erlernen von Informationen aus einem Qubit und zum Aufzählen von Vorgängen, z. b. und, verwenden, [`X`](xref:microsoft.quantum.intrinsic.x) [`H`](xref:microsoft.quantum.intrinsic.h) um auf den Zustand eines Qubit zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="27364-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="27364-119">Diese Vorgänge *werden tatsächlich nur* vom Zielcomputer durchgeführt, der zum Ausführen des jeweiligen Programms verwendet wurde Q# .</span><span class="sxs-lookup"><span data-stu-id="27364-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="27364-120">Wenn Sie das Programm z. b. in unserem [vollständigen Simulator](xref:microsoft.quantum.machines.full-state-simulator)ausführen, führt der Simulator die entsprechenden mathematischen Operationen für das simulierte Quantum-System aus.</span><span class="sxs-lookup"><span data-stu-id="27364-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="27364-121">Wenn der Zielcomputer jedoch ein echter Quantum-Computer ist, wird der Quantum-Computer durch den Aufruf solcher Vorgänge in angewiesen, Q# die entsprechenden *echten* Vorgänge auf dem *realen* Quantum-System auszuführen, z. b. genau zeitgesteuerte Laserpulse.</span><span class="sxs-lookup"><span data-stu-id="27364-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="27364-122">Ein Q# Programm kombiniert diese Vorgänge so, wie Sie von einem Zielcomputer definiert wurden, um neue Vorgänge auf höherer Ebene zum Ausdrücken von Quantum-Berechnungen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="27364-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="27364-123">Auf diese Weise ist Q# es einfacher, die Logik zugrunde liegende Quantum und Hybrid Quantum – klassische Algorithmen auszudrücken, während dies auch in Bezug auf die Struktur eines Ziel Computers oder Simulators allgemein ist.</span><span class="sxs-lookup"><span data-stu-id="27364-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="no-locq-operations-and-functions"></a><span data-ttu-id="27364-124">Q# Vorgänge und Funktionen</span><span class="sxs-lookup"><span data-stu-id="27364-124">Q# operations and functions</span></span>

<span data-ttu-id="27364-125">Konkret umfasst ein Q# Programm *Vorgänge*, *Funktionen*und beliebige benutzerdefinierte Typen.</span><span class="sxs-lookup"><span data-stu-id="27364-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="27364-126">Vorgänge werden verwendet, um die Transformationen von Quantum-Systemen zu beschreiben, und sind die grundlegendsten Bausteine von Q# Programmen.</span><span class="sxs-lookup"><span data-stu-id="27364-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="27364-127">Jeder in definierte Vorgang Q# kann dann eine beliebige Anzahl anderer Vorgänge aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="27364-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="27364-128">Im Gegensatz zu Vorgängen werden Funktionen verwendet, um reines *deterministisches* klassisches Verhalten zu beschreiben, und Sie haben keine Auswirkungen, außer wenn Sie klassische Werte berechnen.</span><span class="sxs-lookup"><span data-stu-id="27364-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="27364-129">Angenommen, Sie möchten die Qubits am Ende eines Programms messen und die Messergebnisse einem Array hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="27364-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="27364-130">In diesem Fall `Measure` ist ein *Vorgang* , der den Zielcomputer anweist, eine Maßeinheit für die (echte oder simulierte) Qubits auszuführen.</span><span class="sxs-lookup"><span data-stu-id="27364-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="27364-131">Gleichzeitig verarbeiten *Funktionen* den klassischen Prozess des Hinzufügens der zurückgegebenen Ergebnisse zu einem Array.</span><span class="sxs-lookup"><span data-stu-id="27364-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="27364-132">Vorgänge und Funktionen werden auch als *callables*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="27364-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="27364-133">Die zugrunde liegende Struktur und das zugehörige Verhalten werden in [Vorgängen und Q# Funktionen in ](xref:microsoft.quantum.guide.operationsfunctions)eingeführt und ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="27364-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="no-locq-syntax-overview"></a><span data-ttu-id="27364-134">Q# Syntax Übersicht</span><span class="sxs-lookup"><span data-stu-id="27364-134">Q# syntax overview</span></span>

<span data-ttu-id="27364-135">Die Syntax einer Sprache beschreibt die verschiedenen Kombinationen von Symbolen, die ein syntaktisch korrektes Programm bilden.</span><span class="sxs-lookup"><span data-stu-id="27364-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="27364-136">In Q# werden Syntax Elemente in drei unterschiedliche Gruppen eingeteilt: Typen, Ausdrücke und Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="27364-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="27364-137">Typen</span><span class="sxs-lookup"><span data-stu-id="27364-137">Types</span></span>
<span data-ttu-id="27364-138">Q# ist eine stark typisierte Sprache, sodass der Compiler bei der sorgfältigen Verwendung von Typen bei der Kompilierung starke Garantien für Programme bereitstellen kann Q# .</span><span class="sxs-lookup"><span data-stu-id="27364-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="27364-139">Zusätzlich zu den standardmäßigen und Quantum-spezifischen integrierten primitiven Typen, z. b. `Int` , `Bool` , `Qubit` und `Result` , Q# bietet Unterstützung für benutzerdefinierte Typen.</span><span class="sxs-lookup"><span data-stu-id="27364-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="27364-140">Beschreibungen aller primitiven Typen, Details zu Array-und Tupeltypen sowie Schritte zum Definieren neuer Typen innerhalb einer Q# Datei finden Sie unter [Typen in Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="27364-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="27364-141">Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="27364-141">Expressions</span></span>
<span data-ttu-id="27364-142">Ein Ausdruck in einer Programmiersprache ist eine Kombination aus einer oder mehreren Konstanten, Variablen, Operatoren und Funktionen, die von der Programmiersprache interpretiert und zu einem bestimmten Wert ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="27364-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="27364-143">In den meisten Fällen können Ausdrücke dieses Typs für jeden Typ in einer Sprache entweder *Literale* oder Symbole sein, die an einen Wert dieses Typs gebunden sind.</span><span class="sxs-lookup"><span data-stu-id="27364-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="27364-144">Beispielsweise `5` ist ein `Int` Literalzeichen (also auch ein Ausdruck vom Typ `Int` ), und wenn das Symbol `count` an den ganzzahligen Wert gebunden ist `5` , dann `count` ist auch ein ganzzahliger Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="27364-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="27364-145">Außerdem kann ein Ausdruck aus anderen Ausdrücken bestehen, die von bestimmten Operatoren kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="27364-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="27364-146">Ein anderer Ausdruck, `Int` der ergibt, ist z `5` . b `2+3` ..</span><span class="sxs-lookup"><span data-stu-id="27364-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="27364-147">Weitere Informationen zu Ausdrücken und kompatiblen Operatoren in Q# finden Sie unter [typausdrücke Q# in ](xref:microsoft.quantum.guide.expressions).</span><span class="sxs-lookup"><span data-stu-id="27364-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="27364-148">Anweisungen</span><span class="sxs-lookup"><span data-stu-id="27364-148">Statements</span></span> 
<span data-ttu-id="27364-149">Eine-Anweisung ist eine syntaktische Einheit einer imperativen Programmiersprache, die einige auszuführende Aktionen ausdrückt. Anweisungen, die mit Ausdrücken in der Anweisung vergleichen, geben keine Ergebnisse zurück und werden ausschließlich für Ihre Nebeneffekte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="27364-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are run solely for their side effects.</span></span> <span data-ttu-id="27364-150">Ausdrücke geben jedoch immer ein Ergebnis zurück und haben oft keine Nebeneffekte.</span><span class="sxs-lookup"><span data-stu-id="27364-150">Expressions, however, always return a result and often do not have any side effects.</span></span> <span data-ttu-id="27364-151">Kurz gesagt Q# werden-Anweisungen ausgeführt, während Ausdrücke ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="27364-151">In short, Q# statements are run, while expressions are evaluated.</span></span>

<span data-ttu-id="27364-152">Ein einfaches Beispiel für eine-Anweisung in Q# ist das Zuweisen eines Symbols zu einem Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="27364-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="27364-153">Ein interessanteres Beispiel ist die `for` -Anweisung, die Iterationen unterstützt und einen- *Anweisungsblock*enthält.</span><span class="sxs-lookup"><span data-stu-id="27364-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="27364-154">Angenommen `qubits` ist das Symbol, das an ein Register von Qubits gebunden ist (technisch gesehen vom Typ `Qubit[]` oder ein Array von `Qubit` Typen).</span><span class="sxs-lookup"><span data-stu-id="27364-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="27364-155">Then</span><span class="sxs-lookup"><span data-stu-id="27364-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="27364-156">ist eine-Anweisung, die jedes Qubit im Register durchläuft, wobei jeweils der Vorgang durchgeführt wird `H` .</span><span class="sxs-lookup"><span data-stu-id="27364-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="27364-157">Beachten Sie, dass `H(qubit);` auch eine-Anweisung in sich selbst ist.</span><span class="sxs-lookup"><span data-stu-id="27364-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="27364-158">Sie können einen beliebigen aufrufsausdruck vom Typ `Unit` (ein `Unit` Typ gibt keine Informationen zurückgeben) als-Anweisung verwenden.</span><span class="sxs-lookup"><span data-stu-id="27364-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="27364-159">Diese Art von Ausdruck ist nützlich, wenn Vorgänge für Qubits aufgerufen werden, die zurückgeben, `Unit` da der Zweck der Anweisung darin besteht, den impliziten Quantum-Zustand zu ändern.</span><span class="sxs-lookup"><span data-stu-id="27364-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="27364-160">Ausdrucks Auswertungs Anweisungen erfordern ein abschließendes Semikolon.</span><span class="sxs-lookup"><span data-stu-id="27364-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="27364-161">Sie verwenden-Anweisungen, um nahezu jeden Aspekt eines Q# Programms zu erstellen, und keine einzelne Seite kann alle Informationen im Zusammenhang mit Ihnen einschließen.</span><span class="sxs-lookup"><span data-stu-id="27364-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="27364-162">Weitere Informationen zur lexikalischen Struktur und Formatierung finden Sie unter " [ Q# Dateistruktur](xref:microsoft.quantum.guide.filestructure)". Informationen zur Zuweisung und zum Gültigkeitsbereich von Symbol Bindungen finden Sie unter [Variablen in Q# ](xref:microsoft.quantum.guide.variables), und für Ablauf Steuerungs Schleifen wie `for` , siehe [Ablauf Steuerung in Q# ](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="27364-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="27364-163">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="27364-163">Next steps</span></span>

<span data-ttu-id="27364-164">Beginnen Sie mit dem Erlernen von [Typen in Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="27364-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="27364-165">Weitere Hintergrundinformationen zu den Grundlagen und der Motivation dahinter Q# finden [Sie unter Warum brauchen wir Q# ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="27364-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
