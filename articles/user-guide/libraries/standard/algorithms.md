---
title: Quantum-Algorithmen inQ#
description: Erfahren Sie mehr über grundlegende Quantum Computing-Algorithmen, einschließlich Amplitude-Verstärkung, Fourier Transform, Draper und Beauregard-Adders und Phasen Schätzung.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- Q#
- $$v
ms.openlocfilehash: 0b5972480061c460345057285bbfe53305acc122
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868813"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="148f2-103">Quantum-Algorithmen</span><span class="sxs-lookup"><span data-stu-id="148f2-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="148f2-104">Amplitudenverstärkung</span><span class="sxs-lookup"><span data-stu-id="148f2-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="148f2-105">Die *Amplitude-Verstärkung* ist eines der grundlegenden Tools von Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="148f2-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="148f2-106">Es ist die grundlegende Idee, dass die Suche, die Amplitude-Schätzung und viele Quantum Machine Learning-Algorithmen zugrunde liegen.</span><span class="sxs-lookup"><span data-stu-id="148f2-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="148f2-107">Es gibt viele Varianten, und in wird Q# eine allgemeine Version basierend auf der schrägen Amplitude-Verstärkung mit partiellen Reflektionen bereitgestellt, um den größten Anwendungsbereich zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="148f2-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="148f2-108">Die zentrale Idee hinter der Amplitude-Verstärkung besteht darin, die Wahrscheinlichkeit eines gewünschten Ergebnisses zu verstärken, indem eine Sequenz von Reflektionen durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="148f2-109">Diese Reflektionen drehen den Anfangszustand näher an den gewünschten Zielzustand, der häufig als markierter Zustand bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="148f2-110">Insbesondere wenn die Wahrscheinlichkeit, dass der Anfangszustand in einem markierten Zustand gemessen wird, $ \sin ^ 2 (\urta) $ ist, wird nach dem Anwenden der Amplitude-Verstärkung $m $ die Erfolgswahrscheinlichkeit auf $ \sin ^ 2 ((2 m + 1) \urta) $ festgelegt.</span><span class="sxs-lookup"><span data-stu-id="148f2-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="148f2-111">Dies bedeutet, dass, wenn $ \teta = \ Pi/[2 (2n + 1)] $ für einen Wert von $n $ ist, die Amplitude-Verstärkung die Wahrscheinlichkeit des Erfolgs auf $100 \\ % $ nach $n $ Iterationen der Amplitude-Verstärkung erhöhen kann.</span><span class="sxs-lookup"><span data-stu-id="148f2-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="148f2-112">Da $ \Der Ta = \sin ^ {-1} (\sqrt{\pr (Success)}) $, bedeutet dies, dass die Anzahl der Iterationen, die erforderlich sind, um einen erfolgreichen Abruf zu erzielen, quadratisch niedriger ist als die erwartete Anzahl, die für die Suche nach einem markierten Zustand nicht deterministisch mithilfe der zufälligen Stichprobenentnahme benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="148f2-113">Für jede Iterations der Amplitude-Verstärkung müssen zwei reflektionsoperatoren angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="148f2-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="148f2-114">Insbesondere, wenn $Q $ der Amplitude-Verstärkungs Vorgang ist und $P _0 $ ein Projektor-Operator auf den ursprünglichen Teilbereich ist und $P _1 $ der Projektor auf dem markierten Teilbereich ist, dann $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="148f2-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="148f2-115">Denken Sie daran, dass es sich bei einem Projektor um einen hermitian-Operator handelt, der die Eigenwerte $ + $1 und $0 $ aufweist und als Ergebnis $ (\boldone-2P_0) $ einheitlich ist, da es Eigenwerte aufweist, die die Stämme von Unity sind (in diesem Fall $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="148f2-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="148f2-116">Stellen Sie sich als Beispiel die Groß-/Kleinschreibung der Grover-Suche mit dem anfänglichen Status $H ^ {\otimes n} \ket {0} $ und dem markierten Status $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ und $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="148f2-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="148f2-117">In den meisten Anwendungen der Amplitude-Verstärkung $P _0 $ ein Projektor auf einen Ausgangszustand, was bedeutet, dass $P _0 = \boldone-2 \ Ket {\ PSI} \ Bra {\ PSI} $ für einen Vektor $ \ket{\psi} $; bei einer pervious Amplitude-Verstärkung $P _0 $ in der Regel in viele Quantum-Zustände projiziert (d. h. die Multiplizität des $ + $1-Eigenwerts von $P _0 $ ist größer als $1 $).</span><span class="sxs-lookup"><span data-stu-id="148f2-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="148f2-118">Die Logik hinter der Amplitude-Verstärkung folgt direkt aus der Eigen Zerlegung von $Q $.</span><span class="sxs-lookup"><span data-stu-id="148f2-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="148f2-119">Insbesondere die Eigenvektoren von $Q $, dass der anfängliche Zustand, der nicht 0 (null) unterstützt, eine lineare Kombination der $ + $1-Eigenvektoren von $P _0 $ und $P _1 $ sind.</span><span class="sxs-lookup"><span data-stu-id="148f2-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="148f2-120">Insbesondere kann der anfängliche Status für die Amplitude-Verstärkung (vorausgesetzt, dass es sich um einen $ + $1-eigen Vektor $P _0 $) als $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\der Ta} \ Ket {\ psi_ +} + e ^ {-i\der Ta} \ Ket {\ psi_-} \right) $ $ WHERE $ \ket{\ psi_ \pm} $ sind Eigenvektoren von $Q $ mit eigen Werten $e ^ {\pm 2i \ der TA} $ und verfügen nur über Unterstützung für die $ + $1-Eigenvektoren der $P _0 $ und $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="148f2-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="148f2-121">Die Tatsache, dass die Eigenwerte $e ^ {\pm i \thta} $ sind, impliziert, dass der Operator $Q $ eine Drehung in einem zweidimensionalen Teilbereich durchführt, der von den beiden Projektoren festgelegt wird, und den ursprünglichen Zustand, in dem der Drehungs Winkel $2 \ Teta $ ist.</span><span class="sxs-lookup"><span data-stu-id="148f2-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="148f2-122">Aus diesem Grund ist die Erfolgswahrscheinlichkeit nach $m $ Iterationen von $Q $ die Erfolgswahrscheinlichkeit $ \sin ^ 2 ([2M + 1] \urta) $.</span><span class="sxs-lookup"><span data-stu-id="148f2-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="148f2-123">Eine weitere nützliche Eigenschaft, die daraus resultiert, besteht darin, dass der Eigen Wert $ \teta $ direkt mit der Wahrscheinlichkeit verknüpft ist, dass der Anfangszustand markiert wäre (in dem Fall, dass $P _0 $ ein Projektor ist, der nur den ursprünglichen Zustand aufweist).</span><span class="sxs-lookup"><span data-stu-id="148f2-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="148f2-124">Da die eigen Phasen von $Q $ $2 \ der TA = 2 \ Sin ^ {-1} (\sqrt{\pr (Success)}) $ lauten, folgt Folgendes: Wenn wir die Phasen Schätzung auf $Q $ anwenden, können wir die Erfolgswahrscheinlichkeit für ein einheitliches Quantum-Verfahren ermitteln.</span><span class="sxs-lookup"><span data-stu-id="148f2-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="148f2-125">Dies ist hilfreich, da hierfür quadratisch weniger Anwendungen des Quantums ausgeführt werden müssen, um die Erfolgswahrscheinlichkeit zu erlernen, als andernfalls erforderlich wäre.</span><span class="sxs-lookup"><span data-stu-id="148f2-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="148f2-126">Q#führt die Amplitude-Verstärkung als Spezialisierung der schrägen Amplitude-Verstärkung ein.</span><span class="sxs-lookup"><span data-stu-id="148f2-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="148f2-127">Eine schrägende Amplitude-Verstärkung verdient diesen Moniker, da der Projektor auf dem anfänglichen eigen Raum keinen Projektor auf dem ursprünglichen Zustand aufweisen muss.</span><span class="sxs-lookup"><span data-stu-id="148f2-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="148f2-128">In diesem Sinne ist das Protokoll für den ursprünglichen Zustand nicht sichtbar.</span><span class="sxs-lookup"><span data-stu-id="148f2-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="148f2-129">Die Schlüssel Anwendung der schrägen Amplitude-Verstärkung erfolgt in bestimmten *linearen Kombinationen von einheitlichen* hamiltona-Simulationsmethoden, bei denen der ursprüngliche Zustand unbekannt ist, aber mit einem Ancilla-Register im Simulations Protokoll entkoppelt wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="148f2-130">Wenn dieses Ancilla-Register als fester Wert gemessen werden soll, z. b. $0 $, dann wenden solche Simulationsmethoden die gewünschte einheitliche Transformation auf die restlichen Qubits an (so genannte System Register).</span><span class="sxs-lookup"><span data-stu-id="148f2-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="148f2-131">Alle anderen Messergebnisse führen jedoch zu einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="148f2-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="148f2-132">Eine schrägende Amplitude-Verstärkung ermöglicht, dass die Wahrscheinlichkeit, dass diese Messung erfolgreich ist, auf $100 \\ % $ mithilfe der oben genannten Argumentation erhöht werden kann.</span><span class="sxs-lookup"><span data-stu-id="148f2-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="148f2-133">Außerdem entspricht die gewöhnliche Amplitude-Verstärkung dem Fall, in dem das System Register leer ist.</span><span class="sxs-lookup"><span data-stu-id="148f2-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="148f2-134">Aus diesem Grund Q# verwendet die Verstärkung der Amplitude-Verstärkung als grundlegende Amplitude-Verstärkungs Unterroutine.</span><span class="sxs-lookup"><span data-stu-id="148f2-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="148f2-135">Die allgemeine Routine ( `AmpAmpObliviousByReflectionPhases` ) verfügt über zwei Register, die `ancillaRegister` als und bezeichnet werden `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="148f2-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="148f2-136">Außerdem werden zwei Oracles für die erforderlichen Reflektionen akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="148f2-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="148f2-137">Der `ReflectionOracle` verhält sich nur auf dem, `ancillaRegister` während der `ObliviousOracle` für beide Register gemeinsam agiert.</span><span class="sxs-lookup"><span data-stu-id="148f2-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="148f2-138">Die Eingabe für `ancillaRegister` muss mit dem Eigen Zustand "-1" des ersten reflektionsoperators "$ \boldone-2P_1 $" initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="148f2-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="148f2-139">In der Regel bereitet das Oracle den Status in der Berechnungsbasis $ \ket{0...0} $ vor.</span><span class="sxs-lookup"><span data-stu-id="148f2-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="148f2-140">In unserer Implementierung werden die `ancillaRegister` konfime von einem Qubit ( `flagQubit` ), das den `stateOracle` und den Rest der gewünschten ancillas steuert.</span><span class="sxs-lookup"><span data-stu-id="148f2-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="148f2-141">`stateOracle`Wird angewendet, wenn auf `flagQubit` $ \ket $ festgelegt ist {1} .</span><span class="sxs-lookup"><span data-stu-id="148f2-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="148f2-142">Eine kann auch Oracles `StateOracle` und `ObliviousOracle` anstelle von Reflektionen über einen-Befehl bereitstellen `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="148f2-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="148f2-143">Wie bereits erwähnt, ist die herkömmliche Amplitude-Verstärkung nur ein Sonderfall dieser Routinen, bei denen `ObliviousOracle` der Identitäts Operator ist und keine System-Qubits vorhanden sind (d. h. `systemRegister` leer ist).</span><span class="sxs-lookup"><span data-stu-id="148f2-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="148f2-144">Wenn Sie Phasen für partielle Reflektionen (z. b. für die Grover-Suche) abrufen möchten, ist die-Funktion `AmpAmpPhasesStandard` verfügbar.</span><span class="sxs-lookup"><span data-stu-id="148f2-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="148f2-145">Unter finden Sie `DatabaseSearch.qs` eine Beispiel Implementierung des Grover-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="148f2-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="148f2-146">Wir verknüpfen die Single-Qubit-Rotations Phasen mit den Reflexions Operator Phasen, wie im Dokument von [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="148f2-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="148f2-147">Die verwendeten festgelegten Punkt Phasen werden in " [yum", "Low" und "Chuang](https://arxiv.org/abs/1409.3305) " zusammen mit den Phasen " [niedrig", "Yoder" und "Chuang](https://arxiv.org/abs/1603.03996)" ausführlich erläutert</span><span class="sxs-lookup"><span data-stu-id="148f2-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="148f2-148">Für den Hintergrund könnten Sie von der [Standard mäßigen Amplitude-Verstärkung](https://arxiv.org/abs/quant-ph/0005055) ausgehen und dann zu einer Einführung in die [pervious Amplitude-Verstärkung](https://arxiv.org/abs/1312.1414) und schließlich zu den in [niedrig und Chuang](https://arxiv.org/abs/1610.06546)dargestellten verallgemeinerungs Vorrichtungen wechseln.</span><span class="sxs-lookup"><span data-stu-id="148f2-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="148f2-149">Eine schöne Übersichts Darstellung dieses gesamten Bereichs (im Zusammenhang mit der hamiltona-Simulation) wurde von [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)angegeben.</span><span class="sxs-lookup"><span data-stu-id="148f2-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="148f2-150">Quantum Fourier-Transformation</span><span class="sxs-lookup"><span data-stu-id="148f2-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="148f2-151">Die Fourier-Transformation ist ein grundlegendes Tool der klassischen Analyse und ist ebenso wichtig für Quantum-Berechnungen.</span><span class="sxs-lookup"><span data-stu-id="148f2-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="148f2-152">Darüber hinaus überschreitet die Effizienz von *Quantum Fourier Transform* (QFT) weit mehr, was auf einem klassischen Computer möglich ist, sodass es zu einem der ersten Tools der Wahl ist, wenn ein Quantum-Algorithmus entworfen wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="148f2-153">Als ungefähre Generalisierung der QFT stellen wir den Vorgang bereit, der <xref:microsoft.quantum.canon.approximateqft> Weitere Optimierungen ermöglicht, indem Rotationen bereinigt werden, die für die gewünschte algorithmische Genauigkeit nicht unbedingt notwendig sind.</span><span class="sxs-lookup"><span data-stu-id="148f2-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="148f2-154">Der ungefähre QFT erfordert die dyadic-$Z $-Rotation-Vorgang <xref:microsoft.quantum.intrinsic.rfrac> und den- <xref:microsoft.quantum.intrinsic.h> Vorgang.</span><span class="sxs-lookup"><span data-stu-id="148f2-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="148f2-155">Es wird davon ausgegangen, dass die Eingabe und die Ausgabe in Big Endian-Codierung codiert werden---d. h., das Qubit mit Index `0` wird im äußersten äußersten (höchsten) Bit der binären ganzzahligen Darstellung codiert.</span><span class="sxs-lookup"><span data-stu-id="148f2-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="148f2-156">Dies richtet sich nach der [Ket-Notation](xref:microsoft.quantum.concepts.dirac), da das Registrieren von drei Qubits im Status $ \ket {100} $ $q _0 $ im Status $ \ket $ entspricht, {1} während sich die $q _1 $ und $q _2 $ im Status $ \ket {0} $ befinden.</span><span class="sxs-lookup"><span data-stu-id="148f2-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="148f2-157">Der Näherungs Parameter $a $ bestimmt die Bereinigungs Ebene der $Z $-Drehungen, d. h. $a \in [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="148f2-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="148f2-158">In diesem Fall werden alle $Z $-Drehungen $2 \ Pi/2 ^ k $, wobei $k > a $ aus der QFT-Leitung entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="148f2-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="148f2-159">Es ist bekannt, dass für $k \ge \ Log_2 (n) + \ Log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="148f2-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="148f2-160">eine kann $ \\ | \operatschmue{QFT}-\operatschmue{aqft} \\ | < \epsilon $ binden.</span><span class="sxs-lookup"><span data-stu-id="148f2-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="148f2-161">Hier \\ ist $ | \cdot \\ | $ die Operator Norm, bei der es sich in diesem Fall um die Quadratwurzel des größten [Eigenwerts](xref:microsoft.quantum.concepts.matrix-advanced) von $ (\operatorname{QFT}-\operatorname{aqft}) handelt (\operatorname{QFT}-\operatorname{aqft}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="148f2-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="148f2-162">Arithmetik</span><span class="sxs-lookup"><span data-stu-id="148f2-162">Arithmetic</span></span> ##

<span data-ttu-id="148f2-163">Ebenso wie Arithmetik beim klassischen Computing eine zentrale Rolle spielt, ist Sie auch bei der Quantenberechnung unverzichtbar.</span><span class="sxs-lookup"><span data-stu-id="148f2-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="148f2-164">Algorithmen, wie z. b. der factoringalgorithmus von Shor, Quantum-Simulationsmethoden und viele für die Organisation basierende Algorithmen basieren auf zusammenhängenden arithmetischen Operationen.</span><span class="sxs-lookup"><span data-stu-id="148f2-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="148f2-165">Die meisten Ansätze für die arithmetische Erstellung bei quantadder-Leitungen.</span><span class="sxs-lookup"><span data-stu-id="148f2-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="148f2-166">Der einfachste Adder nimmt eine klassische Eingabe $b $ und fügt den Wert einem Quantum-Zustand mit einer Ganzzahl von $ \ket{a} $ hinzu.</span><span class="sxs-lookup"><span data-stu-id="148f2-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="148f2-167">Mathematisch hat der Adler (der $ \operatschmue{Add} (b) $ für die klassische Eingabe $b $) die Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="148f2-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="148f2-168">$ $ \operatschmue{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="148f2-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="148f2-169">$ $ Diese einfache Adder-Leitung ist eher inkrementierter als ein Adder.</span><span class="sxs-lookup"><span data-stu-id="148f2-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="148f2-170">Sie kann in einen Adder konvertiert werden, der über $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b} über zwei Quantum-Eingaben verfügt. $ $ using $n $-gesteuerten Anwendungen von addern in der Form \begin{align} \operatschmue{Add} \ket{a} \ket{b} & = \lambda \_ {a \_ 0} \left (\operatschmue{Add} (1) \right) \lambda \_ {a \_ 1} \left (\operatorname{Add} (2) \right) \lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \lambda \_ {a \_ {n-1}} \left (\operatschmue{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} für $n $-Bit-Ganzzahlen $a $ und $b $ und Addition Modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="148f2-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="148f2-171">Beachten Sie, dass die Notation $ \lambda \_ x (A) $ für jeden Vorgang $A $ auf die gesteuerte Version dieses Vorgangs mit dem Qubit $x $ as-Steuerelement verweist.</span><span class="sxs-lookup"><span data-stu-id="148f2-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="148f2-172">Ebenso kann die klassisch kontrollierte Multiplikation (eine modulare Form, die für den Shor-Factoring-Algorithmus unverzichtbar ist) mithilfe einer ähnlichen Reihe von kontrollierten Ergänzungen ausgeführt werden: \begin{align} \operatschmue{mult} (a) \ket{x}\ket{b} & = \lambda \_ {x \_ 0} \left (\operatornamental e{Add} (2 ^ 0 a) \right) \lambda \_ {a \_ 1} \left (\operatschmue{Add} (2 ^ 1a) \right) \lambda \_ {a \_ 2} \left (\operatschmue{Add} (2 ^ 2 a) \right) \cdots \lambda \_ {x \_ {n-1}} \left (\operatschmue{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="148f2-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="148f2-173">\end{align} es gibt eine Untergrenze für die Multiplikation auf Quantum-Computern, die Sie möglicherweise aus der Definition von $ \operatschmue{mult} $ oben bemerken.</span><span class="sxs-lookup"><span data-stu-id="148f2-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="148f2-174">Anders als bei der Addition speichert die Quantum-Version dieser Verbindung das Produkt der Eingaben in einem Zusatz Register anstelle des Eingabe Registers.</span><span class="sxs-lookup"><span data-stu-id="148f2-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="148f2-175">In diesem Beispiel wird das Register mit dem Wert $b $ initialisiert, aber in der Regel wird der Wert 0 (null) beibehalten.</span><span class="sxs-lookup"><span data-stu-id="148f2-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="148f2-176">Dies ist in erforderlich, da im Allgemeinen keine Multiplikations Umkehrung für den allgemeinen $a $ und $x $ vorliegt.</span><span class="sxs-lookup"><span data-stu-id="148f2-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="148f2-177">Da alle Quantum-Vorgänge, die Maßeinheit, nicht umkehrbar sind, müssen wir genügend Informationen aufbewahren, um die Multiplikation umzukehren.</span><span class="sxs-lookup"><span data-stu-id="148f2-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="148f2-178">Aus diesem Grund wird das Ergebnis in einem separaten Array gespeichert.</span><span class="sxs-lookup"><span data-stu-id="148f2-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="148f2-179">Dieser Trick zum Speichern der Ausgabe eines nicht rückgängig-Vorgangs, wie Multiplikation, in einem separaten Register wird nach Charlie Bennett als "Bennett-Trick" bezeichnet und ist ein grundlegendes Tool sowohl bei der umkehrbaren als auch bei der quantumberechnung.</span><span class="sxs-lookup"><span data-stu-id="148f2-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="148f2-180">Viele Quantum-Verbindungen wurden hinzugefügt, und jede untersucht einen anderen Kompromiss hinsichtlich der Anzahl von Qubits (Leerraum) und der Anzahl von erforderlichen Gate-Vorgängen (Zeit).</span><span class="sxs-lookup"><span data-stu-id="148f2-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="148f2-181">Wir sehen uns die unten stehenden, als Draper Adder (Draper Adder) und den "Beauregard Adder" bezeichneten, äußerst effizienten addern</span><span class="sxs-lookup"><span data-stu-id="148f2-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="148f2-182">Draper Adder</span><span class="sxs-lookup"><span data-stu-id="148f2-182">Draper Adder</span></span> ###

<span data-ttu-id="148f2-183">Der Draper Adder ist wohl einer der elegantesten Quantum-Adders, da er die Quantum-Eigenschaften zum Durchführen der Addition direkt aufruft.</span><span class="sxs-lookup"><span data-stu-id="148f2-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="148f2-184">Der Einblick hinter den Draper Adder besteht darin, dass die Fourier-Transformation verwendet werden kann, um Phasenverschiebungen in eine bitschicht zu übersetzen.</span><span class="sxs-lookup"><span data-stu-id="148f2-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="148f2-185">Danach folgt, dass durch Anwenden einer Fourier-Transformation, Anwenden entsprechender Phasenverschiebungen und anschließendes wieder verwenden der Fourier-Transformation ein Adder implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="148f2-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="148f2-186">Im Gegensatz zu vielen anderen addern, die vorgeschlagen wurden, verwendet der Draper Adder explizit Quantum-Effekte, die durch die Quantum Fourier-Transformation eingeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="148f2-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="148f2-187">Sie verfügt nicht über ein naturklassisches Gegenstück.</span><span class="sxs-lookup"><span data-stu-id="148f2-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="148f2-188">Die einzelnen Schritte der Draper-Adder sind unten angegeben.</span><span class="sxs-lookup"><span data-stu-id="148f2-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="148f2-189">Angenommen, Sie haben zwei $n $-Bit-Qubit registriert die ganzen Zahlen $a $ und $b $, dann für alle $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="148f2-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="148f2-190">$ $, Wenn wir $ $ \ket{\phi \_ k (a)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right) definieren, $ $ dann können Sie nach einiger Algebra sehen, dass $ $ \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 (a)} \otimes \cdots \otimes \ket{\phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="148f2-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="148f2-191">$ $ Der Pfad zum Durchführen eines Adder wird dann klar, nachdem er beobachtet hat, dass die Summe der Eingaben als $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\phi \_ 1 (a + b)} \otimes \cdots \otimes \ket{\phi \_ n (a + b)}</span><span class="sxs-lookup"><span data-stu-id="148f2-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="148f2-192">$ $ Die ganzen Zahlen $b $ und $a $ können dann hinzugefügt werden, indem die gesteuerte Phasen Drehung für jedes der Qubits in der Zerlegung mithilfe der Bits von $b $ As-Steuerelementen durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="148f2-193">Diese Erweiterung kann weiter vereinfacht werden, indem Sie feststellen, dass für beliebige ganzzahlige $j $ und reelle Zahl $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="148f2-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="148f2-194">Dies liegt daran, dass Sie, wenn Sie "$ 360 ^ {\circ} $ degrees ($ 2 \ Pi $ radiane)" in einem Kreis drehen, am Ende genau den Anfang haben.</span><span class="sxs-lookup"><span data-stu-id="148f2-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="148f2-195">Der einzige wichtige Teil von $x $ für $e ^ {i2\pi x} $ ist daher der Bruchteil von $x $.</span><span class="sxs-lookup"><span data-stu-id="148f2-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="148f2-196">Insbesondere, wenn eine binäre Erweiterung der Form $x = y +0. x \_ 0x \_ 2 \ ldots x n $ vorhanden ist, \_ $e ^ {i2\pi x} = e ^ {i2\pi (0). x \_ 0x \_ 2 \ ldots x \_ {n-1})} $ und somit $ $ \ket{\phi \_ k (a + b)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ k\ldots b \_ 1]} \ket {1} \right). $ $ Dies bedeutet, dass beim Durchführen einer Addition durch Erhöhen der einzelnen tensorflow-Faktoren in der Erweiterung der Fourier-Transformation von $ \ket{a} $ die Anzahl der Rotationen verringert wird, wenn $k $ abnimmt.</span><span class="sxs-lookup"><span data-stu-id="148f2-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="148f2-197">Dadurch wird die Anzahl der im Adder benötigten Quantum-Gates erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="148f2-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="148f2-198">Wir bezeichnen die Fourier-Transformation, die Phasen Addition und die umgekehrten Fourier Transform-Schritte, die den Draper Adder als $ \operatschmue{QFT} ^ {-1} \left (\phi \\ \! \operatorname{Add}\right) \operatorname{QFT} $ umfassen.</span><span class="sxs-lookup"><span data-stu-id="148f2-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="148f2-199">Eine Quantum-Verbindung, die diese Vereinfachung verwendet, um den gesamten Prozess zu implementieren, finden Sie unten.</span><span class="sxs-lookup"><span data-stu-id="148f2-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Draper-Adder als Verbindungs Diagramm dargestellt](~/media/draper.svg)

<span data-ttu-id="148f2-201">Jede kontrollierte $e ^ {I2 \ Pi/k} $ Gate in der Verbindung bezieht sich auf ein steuerungsphase.</span><span class="sxs-lookup"><span data-stu-id="148f2-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="148f2-202">Diese Gates verfügen über die-Eigenschaft auf dem Qubits-Paar, für das Sie agieren, $ \ket {00} \mapsto \ket {00} $, aber $ \ket {11} \mapsto e ^ {I2 \ Pi/k} \ Ket {11} $.</span><span class="sxs-lookup"><span data-stu-id="148f2-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="148f2-203">Mit dieser Verbindung können wir zusätzliche Qubits ohne zusätzliche Qubits ausführen, abgesehen von denjenigen, die zum Speichern der Eingaben und Ausgaben benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="148f2-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="148f2-204">Beauregard Adder</span><span class="sxs-lookup"><span data-stu-id="148f2-204">Beauregard Adder</span></span> ###

<span data-ttu-id="148f2-205">Der Beauregard Adder ist ein quantmodularer Adder, der den Draper Adder verwendet, um die Addition Modulo $N $ für eine beliebige positive ganze Zahl $N $ auszuführen.</span><span class="sxs-lookup"><span data-stu-id="148f2-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="148f2-206">Die Bedeutung von Quantum-modularen addern, wie z. b. "Beauregard Adder", ergibt sich in hohem Maße von ihrer Verwendung im modularen exponentiations Schritt im Shor-Algorithmus für die Factoring.</span><span class="sxs-lookup"><span data-stu-id="148f2-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="148f2-207">Ein Quantum-Modultyp hat die folgenden Aktionen für die Quantum-Eingabe $ \ket{b} $ und die klassische Eingabe $a $, wobei $a $ und $b $ als ganze Zahlen mod $N $ erwartet werden. Dies bedeutet, dass Sie das Intervall $ [0, \ldots, N-1] $ aufweisen.</span><span class="sxs-lookup"><span data-stu-id="148f2-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="148f2-208">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N \\ \\ \ket{b + a-N}, & (b + a) \ge N \end{Cases}.</span><span class="sxs-lookup"><span data-stu-id="148f2-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="148f2-209">Der Beauregard-Adder verwendet den Draper Adder (genauer gesagt: $ \phi \\ \! \operatschmue{Add} $), um $a $ und $b $ in der Phase hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="148f2-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="148f2-210">Anschließend wird der gleiche Vorgang verwendet, um zu ermitteln, ob $a + b <N $ durch Subtrahieren von $N $ und testen, ob $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="148f2-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="148f2-211">Die Verbindung speichert diese Informationen in einem zusätzlichen Qubit und fügt dann dem Register $N $ zurück, wenn $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="148f2-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="148f2-212">Anschließend wird die Berechnung dieses hilfbits abgeschlossen (dieser Schritt ist erforderlich, um sicherzustellen, dass die Zuordnung von "Ancilla" nach dem Aufruf von Adder aufgehoben werden kann).</span><span class="sxs-lookup"><span data-stu-id="148f2-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="148f2-213">Die Verbindung für den Beauregard-Adder ist unten angegeben.</span><span class="sxs-lookup"><span data-stu-id="148f2-213">The circuit for the Beauregard adder is given below.</span></span>

!["Beauregard Adder", dargestellt als Leitungs Diagramm](~/media/beau.svg)

<span data-ttu-id="148f2-215">Hier hat das Gate $ \phi \\ \! \operatschmue{Add} $ dieselbe Form wie $ \phi \\ \! \operatschmue{Add} $, mit der Ausnahme, dass die Eingabe in diesem Kontext klassisch anstelle von Quantum ist.</span><span class="sxs-lookup"><span data-stu-id="148f2-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="148f2-216">Dadurch können die kontrollierten Phasen in "$ \phi \\ \! \operatschmue{Add} $" durch Phasen Gates ersetzt werden, die dann zusammen in weniger Vorgänge kompiliert werden können, um sowohl die Anzahl der Qubits und die Anzahl der für den Adder benötigten Gates zu verringern.</span><span class="sxs-lookup"><span data-stu-id="148f2-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="148f2-217">Weitere Informationen finden Sie unter [M. roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) und [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="148f2-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="148f2-218">Quantenphasenschätzung</span><span class="sxs-lookup"><span data-stu-id="148f2-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="148f2-219">Eine besonders wichtige Anwendung der Quantum Fourier-Transformation ist das Erlernen der Eigenwerte einheitlicher Operatoren, ein Problem, das als *Phasen Schätzung*bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="148f2-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="148f2-220">Stellen Sie sich einen einheitlichen $U $ und den Status $ \ket{\phi} $ vor, sodass $ \ket{\phi} $ ein eigen Zustand von $U $ mit unbekannter eigen Wert $ \phi $, \begin{Equation} u\ket {\ Phi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="148f2-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="148f2-221">\end{Equation} wenn nur der Zugriff auf $U $ als Oracle möglich ist, können wir die Phase $ \phi $ erlernen, indem wir verwenden, dass $Z $-Drehungen, die auf das Ziel einer kontrollierten Operation angewendet werden, zurück an das Steuerelement weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="148f2-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="148f2-222">Angenommen, $V $ ist eine kontrollierte Anwendung $U $, so: \begin{align} v (\ket {0} \otimes \ket{\phi}) & = \ket {0} \otimes \ket{\phi} \\ \\ \textrm{und} v (\ket {1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket {1} \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="148f2-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="148f2-223">\end{align} dann, nach Linearität, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \bruchteil {(\ket {0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket {1} \otimes \ket{\phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="148f2-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="148f2-224">\end{align} wir können Begriffe erfassen, um zu ermitteln, dass "\begin{align} V" (\ket{+} \otimes \ket{\phi}) & = \bruch {\ket {0} + e ^ {i \phi} \ket {1} } {\ Sqrt {2} } \otimes \ket{\phi} \\ \\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi}, \end{align}, wobei $R _1 $ der einheitliche ist, der durch den Vorgang angewendet wird <xref:microsoft.quantum.intrinsic.r1> .</span><span class="sxs-lookup"><span data-stu-id="148f2-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="148f2-225">Anders ausgedrückt: die Auswirkung der Anwendung von $V $ ist exakt identisch mit der Anwendung von $R _1 $ mit einem unbekannten Winkel, auch wenn wir nur auf $V $ als Oracle zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="148f2-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="148f2-226">Daher wird für den Rest dieser Diskussion die Phasen Schätzung in Bezug auf $R _1 (\phi) $ erläutert, die wir mit dem sogenannten *Phasen-Kickback*implementieren.</span><span class="sxs-lookup"><span data-stu-id="148f2-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="148f2-227">Da das Steuerelement und das Ziel Register nach diesem Vorgang nicht mehr geändert werden, können wir $ \ket{\phi} $ als Ziel einer kontrollierten Anwendung von $U ^ $2 wieder verwenden, um ein zweites Steuerelement-Qubit auf den Status $R _1 (2 \phi) \ket{+} $ vorzubereiten.</span><span class="sxs-lookup"><span data-stu-id="148f2-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="148f2-228">Auf diese Weise können wir ein Register der Form "\begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket {0} + \) abrufen. Exp (i 2 ^ {j} \phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}, wobei $n $ die erforderliche Anzahl von Genauigkeits Bits ist, und wo wir $ {} \propto $ verwendet haben {} , um anzugeben, dass der normalisierungs Faktor $1/\sqrt{2 ^ n} $ unterdrückt wurde.</span><span class="sxs-lookup"><span data-stu-id="148f2-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="148f2-229">Wenn wir davon ausgehen, dass $ \phi = 2 \pi p/2 ^ k $ für eine ganze Zahl $p $ ist, erkennen wir dies als $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, wobei $p _J $ das $j ^ {\textrm{Th}} $ Bit $2 \pi \phi $ ist.</span><span class="sxs-lookup"><span data-stu-id="148f2-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="148f2-230">Wenn Sie das Adjoint der Quantum Fourier-Transformation anwenden, erhalten wir daher die binäre Darstellung der Phase, die als Quantenzustand codiert ist.</span><span class="sxs-lookup"><span data-stu-id="148f2-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="148f2-231">In Q# wird dies durch den- <xref:microsoft.quantum.characterization.quantumphaseestimation> Vorgang implementiert, der eine <xref:microsoft.quantum.oracles.discreteoracle> implementierende Anwendung von $U ^ m $ als Funktion von positiven ganzen Zahlen $m $ übernimmt.</span><span class="sxs-lookup"><span data-stu-id="148f2-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
