---
title: Quantum-Charakterisierung und-Statistiken
description: Erfahren Sie, wie Sie mithilfe von Mess Statistiken aus Phasen Schätzungen die Ergebnis Werte in der Quantum-Programmierung schätzen.
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 0090fb2b9ac5f3c9d195a3ab02dcd21c848d8ef7
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868626"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="7a424-103">Quantum-Charakterisierung und-Statistiken</span><span class="sxs-lookup"><span data-stu-id="7a424-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="7a424-104">Es ist wichtig, dass Sie die Auswirkungen von Vorgängen charakterisieren können, um nützliche Quantum-Algorithmen zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="7a424-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="7a424-105">Dies ist eine Herausforderung, da jede Messung eines Quantum-Systems höchstens ein Bit von Informationen ergibt.</span><span class="sxs-lookup"><span data-stu-id="7a424-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="7a424-106">Zum Erlernen eines Eigenwerts müssen die Ergebnisse von vielen Messungen zusammengefasst werden, damit der Benutzer die vielen Informationen, die für die Darstellung dieser Konzepte erforderlich sind, ggf. in die Lage versetzt.</span><span class="sxs-lookup"><span data-stu-id="7a424-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="7a424-107">Quantum-Zustände sind besonders ärgerlich, da das [No-Klon-Theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) besagt, dass es keine Möglichkeit gibt, einen beliebigen Quantum-Zustand von einer einzelnen Kopie des Zustands zu erlernen, da Sie dadurch Kopien des Zustands erstellen können.</span><span class="sxs-lookup"><span data-stu-id="7a424-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="7a424-108">Diese Verschleierung des Quantum-Zustands des Benutzers wird in der Tatsache widergespiegelt, dass den Q# Zustand für Quantum-Programme weder verfügbar macht noch definiert *is* .</span><span class="sxs-lookup"><span data-stu-id="7a424-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="7a424-109">Wir nähern uns daher der Quantum-Charakterisierung, indem wir Vorgänge und Zustände als Blackbox behandeln. Dieser Ansatz ist gemeinsam mit der experimentellen Praxis von Quantum-Charakterisierung, Verifizierung und Validierung (qcvv) gemeinsam.</span><span class="sxs-lookup"><span data-stu-id="7a424-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="7a424-110">Die Charakterisierung unterscheidet sich von vielen der anderen Bibliotheken, die bereits erläutert wurden.</span><span class="sxs-lookup"><span data-stu-id="7a424-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="7a424-111">Das Ziel hierbei ist weniger, klassische Informationen über das System zu erlernen, anstatt eine einheitliche Transformation für einen Zustands Vektor durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="7a424-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="7a424-112">Diese Bibliotheken müssen daher sowohl die klassische als auch die Quantum-Informationsverarbeitung kombinieren.</span><span class="sxs-lookup"><span data-stu-id="7a424-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="7a424-113">Iterative Phasen Schätzung</span><span class="sxs-lookup"><span data-stu-id="7a424-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="7a424-114">Das Anzeigen der Quantum-Programmierung in Bezug auf die Quantum-Darstellung schlägt eine sinnvolle Alternative zur Quantum-Phasen Schätzung vor.</span><span class="sxs-lookup"><span data-stu-id="7a424-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="7a424-115">Das heißt, anstelle einer $n $-Qubit-Registrierung, die eine binäre Darstellung der Phase wie in der Quantum-Phasen-Schätzung enthalten soll, können wir die Phasen Schätzung als den Prozess anzeigen, mit dem ein *klassischer* Agent mithilfe von Messungen Eigenschaften eines Quantum-Systems erfährt.</span><span class="sxs-lookup"><span data-stu-id="7a424-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="7a424-116">Wir gehen wie im Quantum-Fall vor, indem wir den Phasen-Kickback verwenden, um die Anwendungen eines Blackbox-Vorgangs in Drehung um einen unbekannten Winkel umzuwandeln. Sie messen jedoch das Ancilla-Qubit, das bei jedem Schritt unmittelbar nach der Drehung gedreht wird.</span><span class="sxs-lookup"><span data-stu-id="7a424-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="7a424-117">Dies hat den Vorteil, dass wir nur ein einzelnes zusätzliches Qubit benötigen, um das in der Quantum-Fall beschriebene Phasen Rückschreiben auszuführen, da wir dann die Phase der Messergebnisse bei jedem Schritt iterativ erlernen.</span><span class="sxs-lookup"><span data-stu-id="7a424-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="7a424-118">Jede der unten vorgeschlagenen Methoden verwendet eine andere Strategie für das Entwerfen von Experimenten und verschiedene Datenverarbeitungsmethoden, um die Phase zu erlernen.</span><span class="sxs-lookup"><span data-stu-id="7a424-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="7a424-119">Sie verfügen jeweils über einen einzigartigen Vorteil, der von strengen Fehler Grenzen bis hin zu den Möglichkeiten zum einbeziehen vorheriger Informationen, zum tolerieren von Fehlern oder zur Verwendung von klassischen Computern mit Arbeitsspeicher verfügt.</span><span class="sxs-lookup"><span data-stu-id="7a424-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="7a424-120">Bei der Erörterung der iterativen Phasen Schätzung wird ein einheitlicher $U $ als schwarzer-Box-Vorgang berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="7a424-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="7a424-121">Wie im Abschnitt zu Oracles in [Datenstrukturen](xref:microsoft.quantum.libraries.data-structures)beschrieben, modelliert der Q# Kanon solche Vorgänge nach dem <xref:microsoft.quantum.oracles.discreteoracle> benutzerdefinierten Typ, der durch den tupeltyp definiert wird `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="7a424-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="7a424-122">Wenn `U : DiscreteOracle` , dann wird `U(m)` $U ^ m $ für implementiert `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="7a424-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="7a424-123">Wenn diese Definition vorhanden ist, wird jeder Schritt der iterativen Phasen Schätzung fortgesetzt, indem ein zusätzliches Qubit im $ \ket{+} $-Status zusammen mit dem ursprünglichen Zustand $ \ket{\phi} $ vorbereitet wird. wir gehen davon aus, dass es sich um einen [eigen Vektor](xref:microsoft.quantum.concepts.matrix-advanced) von $U (m) $, d. h. $U (m) \ket{\phi} = e ^ {im\phi} \ Ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="7a424-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="7a424-124">Anschließend wird eine kontrollierte Anwendung von `U(m)` verwendet, die den Status $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $ vorbereitet.</span><span class="sxs-lookup"><span data-stu-id="7a424-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="7a424-125">Wie im Fall von Quantum ist die Auswirkung einer kontrollierten Oracle-Anwendung exakt mit `U(m)` der Auswirkung von $R _1 $ für die unbekannte Phase auf $ \ket{+} $ identisch, sodass wir die Auswirkungen von $U $ auf diese einfachere Weise beschreiben können.</span><span class="sxs-lookup"><span data-stu-id="7a424-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="7a424-126">Optional dreht der Algorithmus das Steuerelement Qubit durch Anwenden von $R _1 (-m\erta) $, um den Status $ \ket{\psi} = \left (R \_ 1 (m [\phi-\erta]) \ket{+} \right) \ket{\phi} $ $ abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7a424-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="7a424-127">Das zusätzliche Qubit, das als Steuerelement für verwendet `U(m)` wird, wird dann in der $X $-Basis gemessen, um eine einzelne klassische zu erhalten `Result` .</span><span class="sxs-lookup"><span data-stu-id="7a424-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="7a424-128">An diesem Punkt ist das erneute Erstellen der Phase aus den Werten, die `Result` durch die iterative Phasen Schätzung abgerufen werden, ein klassisches Statistisches Typrückschluss-Problem.</span><span class="sxs-lookup"><span data-stu-id="7a424-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="7a424-129">Das Auffinden des Werts $m $, der die gesammelten Informationen mit einer festgelegten Rückschluss Methode maximiert, ist einfach ein Problem in den Statistiken.</span><span class="sxs-lookup"><span data-stu-id="7a424-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="7a424-130">Wir betonen dies, indem wir die iterative Phasen Schätzung auf einer theoretischen Ebene im bayesschen Parameter schätzungsformalität kurz beschreiben, bevor wir mit der Beschreibung der statistischen Algorithmen im Q# Kanon zum lösen dieses klassischen Inferenz Problems fortfahren.</span><span class="sxs-lookup"><span data-stu-id="7a424-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="7a424-131">Iterative Phasen Schätzung ohne eigen Status</span><span class="sxs-lookup"><span data-stu-id="7a424-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="7a424-132">Wenn ein Eingabe Status angegeben wird, der kein eigen Status ist, was heißt, dass bei $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $ der Prozess der Phasen Schätzung nicht deterministisch zu einem einzelnen Energiezustand führt.</span><span class="sxs-lookup"><span data-stu-id="7a424-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="7a424-133">Der eigenständige Zustand, mit dem er letztendlich konvergiert, ist der Eigen Zustand, der höchstwahrscheinlich den beobachteten Wert erzeugt `Result` .</span><span class="sxs-lookup"><span data-stu-id="7a424-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="7a424-134">Der einzige Schritt von PE führt die folgende nicht einheitliche Transformation auf dem Status "\begin{align} \ sum_j \sqrt{\pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ sqrt {\ PR (\phi)" aus. \_ j)} \sqrt{\pr (\text{result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\pr (\phi \_ j) \sum \_ j \pr (\text{result} | \phi \_ j)}}.</span><span class="sxs-lookup"><span data-stu-id="7a424-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="7a424-135">\end{align} wenn dieser Prozess über mehrere `Result` Werte durchlaufen wird, werden eigen Zustände, die keine maximalen Werte von $ \ prod_k \pr (\text{Result} \_ k | \phi \_ j) $ aufweisen, exponentiell unterdrückt.</span><span class="sxs-lookup"><span data-stu-id="7a424-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="7a424-136">Folglich wird der Rückschluss Prozess in der Regel mit einem einzelnen eigen Wert zusammengeführt, wenn die Experimente ordnungsgemäß ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="7a424-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="7a424-137">Bayes ' Theorem gibt weiter an, dass der Zustand, der sich aus der Phasen Schätzung ergibt, in der Form \begin{align} \bruchteil {\sqrt{\pr (\phi \_ j)} \sqrt{\pr (\text{result} | \phi \_ j)} \ket{\phi j geschrieben wird. \_ }} {\sqrt{\pr (\phi \_ j) \sum \_ j \pr (\text{result} | \phi \_ j)}} = \ sum_j \sqrt{\pr (\phi \_ j | \text{result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="7a424-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="7a424-138">\end{align} hier $ \pr (\phi \_ j | \text{result}) $ kann als die Wahrscheinlichkeit interpretiert werden, die für jede Hypothese über die angegebenen Eigenwerte festgestellt wird:</span><span class="sxs-lookup"><span data-stu-id="7a424-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="7a424-139">Kenntnis des Quanten Zustands vor der Messung</span><span class="sxs-lookup"><span data-stu-id="7a424-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="7a424-140">Kenntnis der Eigen Zustände von $U $ und,</span><span class="sxs-lookup"><span data-stu-id="7a424-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="7a424-141">Kenntnis der Eigenwerte von $U $.</span><span class="sxs-lookup"><span data-stu-id="7a424-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="7a424-142">Das Erlernen dieser drei Dinge ist oft exponentiell auf einem klassischen Computer schwierig.</span><span class="sxs-lookup"><span data-stu-id="7a424-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="7a424-143">Das Hilfsprogramm der Phasen Schätzung ergibt sich aus der Tatsache, dass es eine solche Quantum Learning-Aufgabe ausführen kann, ohne dass Sie eine dieser Funktionen kennen.</span><span class="sxs-lookup"><span data-stu-id="7a424-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="7a424-144">Die Phasen Schätzung wird für diesen Grund innerhalb einer Reihe von Quantum-Algorithmen angezeigt, die exponentielle Beschleunigung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="7a424-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="7a424-145">Schätzung der bayesschen Phase</span><span class="sxs-lookup"><span data-stu-id="7a424-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="7a424-146">Ausführlichere Informationen zur bayesschen Phasen Schätzung in der Praxis finden Sie im Beispiel für eine [**phaseschätzungsschätzung**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="7a424-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="7a424-147">Die Idee der bayesschen Phasen Schätzung ist einfach.</span><span class="sxs-lookup"><span data-stu-id="7a424-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="7a424-148">Sie erfassen Mess Statistiken aus dem Phasen Schätz Protokoll und verarbeiten dann die Ergebnisse mit bayesschen Inferenz und geben eine Schätzung des Parameters an.</span><span class="sxs-lookup"><span data-stu-id="7a424-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="7a424-149">Diese Verarbeitung gibt Ihnen eine Schätzung des Eigenwerts und der Ungewissheit in dieser Schätzung.</span><span class="sxs-lookup"><span data-stu-id="7a424-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="7a424-150">Außerdem können Sie Adaptive Experimente durchführen und vorherige Informationen verwenden.</span><span class="sxs-lookup"><span data-stu-id="7a424-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="7a424-151">Der prinzipielle Nachteil der Methode ist, dass Sie Rechen technisch anspruchsvoll ist.</span><span class="sxs-lookup"><span data-stu-id="7a424-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="7a424-152">Um zu verstehen, wie dieser Bayessche Rückschluss Prozess funktioniert, sollten Sie den Fall der Verarbeitung eines einzelnen Ergebnisses in Erwägung gezogen `Zero` .</span><span class="sxs-lookup"><span data-stu-id="7a424-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="7a424-153">Beachten Sie, dass $X = \ket{+} \bra{+}-\ket {-} \bra {-} $ ist, sodass $ \ket{+} $ der einzige positive eigen Zustand von $X $ ist, der entspricht `Zero` .</span><span class="sxs-lookup"><span data-stu-id="7a424-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="7a424-154">Die Wahrscheinlichkeit, `Zero` dass eine [ `PauliX` Messung](xref:microsoft.quantum.concepts.pauli) auf dem ersten Qubit mit dem Eingabe Status $ \ket{\psi}\ket{\phi} $ beobachtet wird, ist folglich \begin{Equation} \pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="7a424-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="7a424-155">\end{Equation} bei iterativer Phasen Schätzung, wir haben das $ \ket{\psi} = R_1 (m [\phi-\urta]) \ket{+} $, sodass \begin{align} \pr (\texttt{Zero} | \phi; m, \orta) & = \left | \braket{+ | R_1 (m [\phi-\orta]) | +} \right | ^ 2 \\ \\ & = \left | \bruchteil 12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\phi-\erta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \bruchteil {1+ e ^ {i m [\phi-\teta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\teta]/2) \tag{★} \label{EQ: Phase-EST-Wahrscheinlichkeit}.</span><span class="sxs-lookup"><span data-stu-id="7a424-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="7a424-156">\end{align} das heißt, die iterative Phasen Schätzung besteht aus dem Erlernen der Schwingungs Häufigkeit einer Sinus förmigem-Funktion, wobei die Möglichkeit besteht, eine Münze mit einer von dieser Sinusoid angegebenen Abweichung zu kippen.</span><span class="sxs-lookup"><span data-stu-id="7a424-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="7a424-157">Nach der herkömmlichen klassischen Terminologie wird $ \eqref{EQ: Phase-EST-Wahrscheinlichkeit} $ die *Wahrscheinlichkeitsfunktion* für die iterative Phasen Schätzung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="7a424-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="7a424-158">Nachdem ein `Result` aus der Wahrscheinlichkeits Wahrscheinlichkeits-Funktion für iterative Phasen beobachtet wurde, können wir die Bayes-Regel verwenden, um vorzuschreiben, was in der Phase der Betrachtung folgen soll.</span><span class="sxs-lookup"><span data-stu-id="7a424-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="7a424-159">Konkret: \begin{Equation} \pr (\phi | d) = \bruchteil {\pr (d | \phi) \pr (\phi)} {\int \pr (d | \phi) \pr (\phi) {\mathrm d} \phi} \pr (\phi), \end{Equation} WHERE $d \in \\ {\texttt{Zero}, \texttt{One} \\ } $ ist `Result` , und WHERE $ \pr (\phi) $ beschreibt unsere früheren Überzeugungen zu $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="7a424-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="7a424-160">Dadurch wird die iterative Phasen Schätzung explizit durchlaufen, da der Wert der nachfolgenden Distribution $ \pr (\phi | d) $ unsere Überzeugungen vor der Betrachtung der nächsten beschreibt `Result` .</span><span class="sxs-lookup"><span data-stu-id="7a424-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="7a424-161">Zu einem beliebigen Zeitpunkt während dieses Verfahrens können wir die Phase $ \hat{\phi} $, die vom klassischen Controller abgeleitet wurde, als "\begin{Equation} \hat{\phi} \mathrel{" melden: =} \erwartet [\phi | \text{Data}] = \int \phi \pr (\phi | \text{Data}) {\mathrm d} \phi, \end{Equation}, wobei $ \text{Data} $ für den gesamten Datensatz aller `Result` erhaltenen Werte steht.</span><span class="sxs-lookup"><span data-stu-id="7a424-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="7a424-162">Der genaue Bayessche Rückschluss ist in der Praxis unlösbar.</span><span class="sxs-lookup"><span data-stu-id="7a424-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="7a424-163">Um dies zu sehen, möchten wir eine $n $-Bit-Variable $x $ erlernen.</span><span class="sxs-lookup"><span data-stu-id="7a424-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="7a424-164">Die vorherige Distribution $ \pr (x) $ unterstützt mehr als $2 ^ n $ hypothetische Werte von $x $.</span><span class="sxs-lookup"><span data-stu-id="7a424-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="7a424-165">Dies bedeutet Folgendes: Wenn wir eine sehr genaue Schätzung $x $ benötigen, ist für die Bayes-Phasen Schätzung möglicherweise eine nicht benötigte Arbeitsspeicher-und Verarbeitungszeit erforderlich.</span><span class="sxs-lookup"><span data-stu-id="7a424-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="7a424-166">Während einige Anwendungen, wie z. b. die Quantum-Simulation, die erforderliche Genauigkeit nicht ausschließt, schließt andere Anwendungen, wie z. b. der Shor-Algorithmus, nicht den exakten bayesschen Rückschluss innerhalb des Phasen Schätz Schritts aus.</span><span class="sxs-lookup"><span data-stu-id="7a424-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="7a424-167">Aus diesem Grund werden auch Implementierungen für ungefähre Bayes-Methoden bereitgestellt, wie z. b. die [Random Walk-Phasen Schätzung (rwpe)](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) und auch nicht-Bayes-Ansätze, wie z. b. eine [robuste Phasen Schätzung](xref:microsoft.quantum.characterization.robustphaseestimation).</span><span class="sxs-lookup"><span data-stu-id="7a424-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="7a424-168">Stabile Phasen Schätzung</span><span class="sxs-lookup"><span data-stu-id="7a424-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="7a424-169">*Eine maximale nach* haltige Bayes-Wiederherstellung einer Phasen Schätzung von Messergebnissen ist im schlimmsten Fall exponentiell schwierig.</span><span class="sxs-lookup"><span data-stu-id="7a424-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="7a424-170">Daher Opfern die meisten praktischen Phasen Schätz Algorithmen eine gewisse Qualität bei der Wiederherstellung, in Exchange für eine Menge klassischer Nachbearbeitung, die stattdessen Polynomisch mit der Anzahl der durchgeführten Messungen skaliert.</span><span class="sxs-lookup"><span data-stu-id="7a424-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="7a424-171">Ein Beispiel mit einem effizienten klassischen Nachbearbeitungsschritt ist der [robuste Phasen Schätz Algorithmus](https://arxiv.org/abs/1502.02677)mit der oben erwähnten Signatur und den oben erwähnten Eingaben.</span><span class="sxs-lookup"><span data-stu-id="7a424-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="7a424-172">Dabei wird davon ausgegangen, dass Eingabe-einheitliche schwarze Felder $U $ als Typ verpackt werden `DiscreteOracle` und daher nur ganzzahlige Kräfte von kontrollierten $U $ Abfragen.</span><span class="sxs-lookup"><span data-stu-id="7a424-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="7a424-173">Wenn der Eingabe Status im `Qubit[]` Register ein eigen Status $U \ket{\psi} = e ^ {i\phi} \ Ket {\ PSI} $ ist, gibt der robuste Algorithmus der Phasen Schätzung eine Schätzung $ \hat{\phi}\in [-\pi, \pi) $ von $ \phi $ als zurück `Double` .</span><span class="sxs-lookup"><span data-stu-id="7a424-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="7a424-174">Das wichtigste Feature der robusten Phasen Schätzung, das gemeinsam mit den meisten anderen nützlichen Varianten verwendet wird, besteht darin, dass die Erfolgs Qualität von $ \hat{\phi} $ in gewisser Weise Heisenberg-Limited ist.</span><span class="sxs-lookup"><span data-stu-id="7a424-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="7a424-175">Dies bedeutet Folgendes: Wenn die Abweichung von $ \hat{\phi} $ von dem Wert "true" den Wert $ \sigma $ hat, wird "$ \sigma $" umgekehrt proportional zur Gesamtanzahl der Abfragen $Q $ an "kontrolliert-$U $" durchgeführt, d. h. $ \sigma = \mathcal{o} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="7a424-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="7a424-176">Nun variiert die Definition der Abweichung zwischen unterschiedlichen Schätz Algorithmen.</span><span class="sxs-lookup"><span data-stu-id="7a424-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="7a424-177">In einigen Fällen kann dies bedeuten, dass bei mindestens $ \mathcal{o} (1) $ Wahrscheinlichkeit der Schätz Fehler $ | \hat{\phi}-\phi | \_ \circ\le \sigma $ bei einem Zirkel Measure $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="7a424-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="7a424-178">Bei einer robusten Phasen Schätzung ist die Abweichung genau die Varianz $ \sigma ^ 2 = \mathbb{e} \_ \hat{\phi} [(\Mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $, wenn wir die Zusammenfassung der periodischen Phasen in einem einzelnen begrenzten Intervall von $ (-\pi, \pi] $) ent</span><span class="sxs-lookup"><span data-stu-id="7a424-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="7a424-179">Genauer: die Standardabweichung in der robusten Phasen Schätzung erfüllt die Ungleichheiten $ $ \begin{align} 2,0 \pi/q \le \sigma \le 2 \ Pi/2 ^ {n} \le 10.7 \ Pi/q, \end{align} $ $, wobei die untere Grenze im Limit von asympmearg Large $Q $ erreicht wird, und die obere Grenze ist auch bei kleinen Stichprobengrößen garantiert.</span><span class="sxs-lookup"><span data-stu-id="7a424-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="7a424-180">Beachten Sie, dass $n $ von der `bitsPrecision` Eingabe ausgewählt wurde, die implizit $Q $ definiert.</span><span class="sxs-lookup"><span data-stu-id="7a424-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="7a424-181">Weitere relevante Details sind z. a. der kleine Speicherplatz, der nur $1 $ Ancilla Qubit ist, oder, wenn die Prozedur nicht Adaptive ist, d. h. die erforderliche Sequenz von Quantum-Experimenten ist unabhängig von den zwischen Messergebnissen.</span><span class="sxs-lookup"><span data-stu-id="7a424-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="7a424-182">In diesem und bevorstehenden Beispielen, in denen der Algorithmus der Phasen Schätzung von Bedeutung ist, sollten Sie in der Dokumentation wie @"microsoft.quantum.characterization.robustphaseestimation" und den referenzierten Veröffentlichungen darauf verweisen, um weitere Informationen und deren Implementierung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="7a424-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="7a424-183">Es gibt viele Beispiele, in denen eine robuste Phasen Schätzung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7a424-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="7a424-184">Die Phasen Schätzung zum Extrahieren der Grund Zustands Energie des unterschiedlichen physischen Systems finden Sie im Beispiel für die [ **H2-Simulation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), das [ **simpleising** -Beispiel](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)und das Beispiel für das Hubbard- [ **Modell** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="7a424-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="7a424-185">Kontinuierliche Oracles</span><span class="sxs-lookup"><span data-stu-id="7a424-185">Continuous Oracles</span></span> ###

<span data-ttu-id="7a424-186">Wir können auch aus dem oben verwendeten Oracle-Modell generalisieren, um fortlaufende Oracles zu ermöglichen, die nach dem Kanatyp modelliert werden <xref:microsoft.quantum.oracles.continuousoracle> .</span><span class="sxs-lookup"><span data-stu-id="7a424-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="7a424-187">Angenommen, anstelle eines einzelnen einheitlichen Operators $U $ haben wir eine Familie einheitlicher Operatoren $U (t) $ für $t \in \mathbb{r} $, sodass $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="7a424-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="7a424-188">Dabei handelt es sich um eine schwächere Anweisung als im diskreten Fall, da wir einen erstellen können, <xref:microsoft.quantum.oracles.discreteoracle> indem wir $t = m \, \delta t $ für einige festgelegte $ \delta t $ einschränken.</span><span class="sxs-lookup"><span data-stu-id="7a424-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="7a424-189">Nach dem [Theorem des Steins](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ für einen Operator $H $, wobei $ \exp $ die Matrix exponentialweise ist, wie in [Advanced Matrizen](xref:microsoft.quantum.concepts.matrix-advanced)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="7a424-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="7a424-190">Der Eigen Status $ \ket{\phi} $ von $H $, sodass $H \ket{\phi} = \phi \ket{\phi} $ auch der Eigen Status $U (t) $ für alle $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="7a424-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="7a424-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="7a424-191">\end{equation}</span></span>

<span data-ttu-id="7a424-192">Genau dieselbe Analyse, die für die Bayes- [Phasen Schätzung](#bayesian-phase-estimation) erläutert wurde, kann angewendet werden. und die Wahrscheinlichkeitsfunktion ist für dieses allgemeinere Oracle-Modell exakt identisch: $ $ \pr (\texttt{Zero} | \phi; t, \orta) = \cos ^ 2 \ Left (\bruchteil {t [\phi-\urta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="7a424-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="7a424-193">Außerdem gilt: Wenn $U $ eine Simulation eines dynamischen Generators ist, wie es bei der [hamiltona-Simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)der Fall ist, wird $ \phi $ als Strom interpretiert.</span><span class="sxs-lookup"><span data-stu-id="7a424-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="7a424-194">Durch die Verwendung der Phasen Schätzung mit kontinuierlichen Abfragen können wir also das simulierte [Strom Spektrum von Molekülen](https://arxiv.org/abs/quant-ph/0604193), [Materialien](https://arxiv.org/abs/1510.03859) oder [Feldtheorien](https://arxiv.org/abs/1111.3633v2) erlernen, ohne unsere Auswahl von Experimenten kompromittieren zu müssen, da $t $ eine ganze Zahl sein muss.</span><span class="sxs-lookup"><span data-stu-id="7a424-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="7a424-195">Schätzung der Zufalls Durchlauf Phase</span><span class="sxs-lookup"><span data-stu-id="7a424-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="7a424-196">Q#bietet eine hilfreiche Näherung der bayyesian-Phasen Schätzung, die für die Verwendung in der Nähe von Quantum-Geräten entwickelt wurde</span><span class="sxs-lookup"><span data-stu-id="7a424-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="7a424-197">Diese Methode ist sowohl adaptiv als auch vollständig deterministisch und ermöglicht eine nahezu optimale Skalierung von Fehlern in der geschätzten Phase $ \hat{\phi} $ mit sehr geringem Arbeitsspeicher Aufwand.</span><span class="sxs-lookup"><span data-stu-id="7a424-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="7a424-198">Das Protokoll verwendet eine ungefähre Bayessche Typrückschluss-Methode, die annimmt, dass die vorherige Verteilung Gaußsch ist.</span><span class="sxs-lookup"><span data-stu-id="7a424-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="7a424-199">Diese gausische Annahme ermöglicht es uns, eine analytische Formel für das Experiment zu verwenden, das die hintere Abweichung minimiert.</span><span class="sxs-lookup"><span data-stu-id="7a424-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="7a424-200">Der Algorithmus verschiebt dann basierend auf dem Ergebnis dieses Experiments die Schätzung von $ \phi $ nach links oder rechts um einen vorab festgelegten Betrag und verkleinert die Varianz um einen vordefinierten Betrag.</span><span class="sxs-lookup"><span data-stu-id="7a424-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="7a424-201">Dieser Mittelwert und die Varianz geben alle Informationen an, die erforderlich sind, um eine gausische vor $ \phi $ für das nächste Experiment anzugeben.</span><span class="sxs-lookup"><span data-stu-id="7a424-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="7a424-202">Unerwartete Messfehler oder das tatsächliche Ergebnis, das sich aus dem anfänglichen früheren Ergebnis ergibt, können dazu führen, dass diese Methode fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="7a424-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="7a424-203">Es wird nach einem Ausfall wieder hergestellt, um zu testen, ob der aktuelle Mittelwert und die Standardabweichung für das System geeignet sind.</span><span class="sxs-lookup"><span data-stu-id="7a424-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="7a424-204">Wenn dies nicht der Fall ist, führt der Algorithmus einen umgekehrten Schritt der exemplarischen Vorgehensweise aus, und der Prozess wird fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="7a424-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="7a424-205">Die Möglichkeit, rückwärts zu wechseln, ermöglicht es dem Algorithmus auch, zu lernen, auch wenn die anfängliche vorherige Standardabweichung nicht sehr klein ist.</span><span class="sxs-lookup"><span data-stu-id="7a424-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="7a424-206">Algorithmen zur Aufruf Phasen Schätzung</span><span class="sxs-lookup"><span data-stu-id="7a424-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="7a424-207">Jeder Phasen Schätz Vorgang, der mit dem Kanon bereitgestellt wird Q# , erfordert einen anderen Satz von Eingaben, der die Qualität parametrisiert, die wir für die abschließende Schätzung $ \hat{\phi} $ verlangen.</span><span class="sxs-lookup"><span data-stu-id="7a424-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="7a424-208">In diesen unterschiedlichen Eingaben werden allerdings mehrere allgemeine Eingaben gemeinsam genutzt, sodass die partielle Anwendung über den Qualitätsparametern eine gängige Signatur zur Folge hat.</span><span class="sxs-lookup"><span data-stu-id="7a424-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="7a424-209">Der <xref:microsoft.quantum.characterization.robustphaseestimation> im nächsten Abschnitt erörterte Vorgang hat z. b. die folgende Signatur:</span><span class="sxs-lookup"><span data-stu-id="7a424-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="7a424-210">Die `bitsPrecision` Eingabe ist eindeutig für `RobustPhaseEstimation` , während `oracle` und `eigenstate` gemeinsam sind.</span><span class="sxs-lookup"><span data-stu-id="7a424-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="7a424-211">So kann ein Vorgang, wie in **H2Sample**gezeigt, einen iterativen Phasen Schätz Algorithmus mit einer Eingabe des Formulars akzeptieren, damit `(DiscreteOracle, Qubit[]) => Unit` ein Benutzer beliebige Phasen Schätz Algorithmen angeben kann:</span><span class="sxs-lookup"><span data-stu-id="7a424-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="7a424-212">Diese unzähligen Phasen Schätz Algorithmen sind für verschiedene Eigenschaften und Eingabeparameter optimiert, die verstanden werden müssen, um die beste Wahl für die Zielanwendung zu treffen.</span><span class="sxs-lookup"><span data-stu-id="7a424-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="7a424-213">Beispielsweise sind einige Phasen Schätz Algorithmen adaptiv, was bedeutet, dass zukünftige Schritte durch die Messergebnisse der vorherigen Schritte klassisch gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="7a424-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="7a424-214">Für einige ist es erforderlich, dass das in der Lage ist, das in der Blackbox einheitliche Oracle-Element von beliebigen echten Kräften zu exponentiell zu machen, und andere benötigen nur ganzzahlige Kräfte, aber nur eine Phasen Schätzung von Modulo $2 \ Pi $ auflösen</span><span class="sxs-lookup"><span data-stu-id="7a424-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="7a424-215">Einige erfordern viele zusätzliche Qubits, und andere erfordern nur eine.</span><span class="sxs-lookup"><span data-stu-id="7a424-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="7a424-216">Analog dazu verläuft die Verwendung der zufälligen walkphasen-Schätzung auf die gleiche Weise wie für andere Algorithmen, die mit dem Kanon bereitgestellt werden:</span><span class="sxs-lookup"><span data-stu-id="7a424-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
