---
title: 'Anwendungen in den :::no-loc(Q#)::: Standardbibliotheken'
description: 'Erfahren Sie mehr über zwei grundlegende Anwendungen in Quantum Computing: hamiltonan Simulation und Shor-Suchalgorithmus.'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 5a29dcc74c638cb8ecbeb1f924d0e50d40d19f66
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692170"
---
# <a name="applications"></a><span data-ttu-id="63089-103">Anwendungen</span><span class="sxs-lookup"><span data-stu-id="63089-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="63089-104">Hamilton-Simulation</span><span class="sxs-lookup"><span data-stu-id="63089-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="63089-105">Die Simulation von Quantum-Systemen ist eine der aufregendsten Anwendungen der Quantum-Berechnung.</span><span class="sxs-lookup"><span data-stu-id="63089-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="63089-106">Auf einem klassischen Computer wird die Schwierigkeit, die Quantum-Mechanismen zu simulieren, im Allgemeinen mit der Dimension $N $ der zugehörigen Zustands Vektordarstellung skaliert.</span><span class="sxs-lookup"><span data-stu-id="63089-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="63089-107">Wenn diese Darstellung exponentiell mit der Anzahl von $n $ Qubits $N = 2 ^ n $ wächst, ist das Merkmal, das auch als [Fluch der Dimensionalität](xref:microsoft.quantum.concepts.multiple-qubits)bezeichnet wird, nicht mehr in die Quantum-Simulation der klassischen Hardware integriert.</span><span class="sxs-lookup"><span data-stu-id="63089-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="63089-108">Allerdings kann die Situation auf der Quantum-Hardware sehr unterschiedlich sein.</span><span class="sxs-lookup"><span data-stu-id="63089-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="63089-109">Die häufigste Variation der Quantum-Simulation ist das zeitunabhängige hamiltona-Simulations Problem.</span><span class="sxs-lookup"><span data-stu-id="63089-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="63089-110">Dort wird eine Beschreibung der System-hamiltonan $H $, eine hermitian-Matrix und ein anfänglicher Quantum-Status $ \ket{\psi (0)} $ bereitgestellt, der in gewisser Weise auf $n $ Qubits auf einem Quantum-Computer codiert wird.</span><span class="sxs-lookup"><span data-stu-id="63089-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="63089-111">Die Quantum-Zustände in geschlossenen Systemen werden unter der Schrödinger-Gleichung $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)} weiterentwickelt, \end{align} $ $ das Ziel ist die Implementierung des einheitlichen Time-Evolution-Operators $U (t) = e ^ {-IHT} $ zu einer festgelegten Zeit $t $, wobei $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ die Schrödinger-Gleichung löst.</span><span class="sxs-lookup"><span data-stu-id="63089-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="63089-112">Analog dazu löst das zeitabhängige hamiltona-Simulations Problem dieselbe Gleichung, aber mit $H (t) $ Now-Funktion.</span><span class="sxs-lookup"><span data-stu-id="63089-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="63089-113">Die hamiltona-Simulation ist eine wesentliche Komponente vieler anderer Probleme bei der Quantum-Simulation, und Lösungen für hamiltonein Simulations Problem sind Algorithmen, die eine Sequenz primitiver Quantum-Gates für die Zusammenstellung eines Näherungs Einheits-"$ \tilde{u} $" mit dem Fehler "$ \\ | \tilde{u}-U \\ [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced)</span><span class="sxs-lookup"><span data-stu-id="63089-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="63089-114">Die Komplexität dieser Algorithmen hängt stark davon ab, wie eine Beschreibung der hamiltona von Interesse für einen Quantum-Computer zugänglich gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="63089-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="63089-115">Wenn beispielsweise im ungünstigsten Fall $H $-$n $ Qubits als Liste von $2 ^ n \times 2 ^ n $-Nummern bereitgestellt werden soll, eine für jedes Matrixelement, ist das einfache Lesen der Daten bereits exponentiell Zeit erforderlich.</span><span class="sxs-lookup"><span data-stu-id="63089-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="63089-116">Im besten Fall könnte der Zugriff auf eine Blackbox-einheitlich angenommen werden, die $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ triviale das Problem löst.</span><span class="sxs-lookup"><span data-stu-id="63089-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="63089-117">Keines dieser Eingabe Modelle ist besonders interessant: das erste ist nicht besser als klassisches Verfahren, und das zweite als das schwarze Feld verbirgt die primitive Gate-Komplexität der Implementierung, die in der Anzahl der Qubits exponentiell sein könnte.</span><span class="sxs-lookup"><span data-stu-id="63089-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="63089-118">Beschreibungen der hamiltonane</span><span class="sxs-lookup"><span data-stu-id="63089-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="63089-119">Daher sind zusätzliche Annahmen des Formats der Eingabe erforderlich.</span><span class="sxs-lookup"><span data-stu-id="63089-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="63089-120">Zwischen den Eingabe Modellen, die ausreichend aussagekräftig sind, müssen interessante hamiltonane berücksichtigt werden, wie z. b. jene für realistische physische Systeme oder interessante Berechnungs Probleme, und Eingabe Modelle, die ausreichend restriktiv sind, um auf einem Quantum-Computer effizient implementiert werden zu können.</span><span class="sxs-lookup"><span data-stu-id="63089-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="63089-121">In der Literatur ist möglicherweise eine Vielzahl von nicht trivialen Eingabe Modellen enthalten, und Sie reichen von Quantum bis Classic.</span><span class="sxs-lookup"><span data-stu-id="63089-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="63089-122">Als Beispiele für Quantum-Eingabe Modelle geht die [Beispiel basierte hamiltona-Simulation](http://www.nature.com/articles/s41534-017-0013-7) von einem Blackbox-Zugriff auf Quantum-Vorgänge aus, die Kopien der Dichte Matrix $ \rho $ erzeugen, die als hamiltona-$H $ verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="63089-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="63089-123">Beim Modell für den [einheitlichen Zugriff](https://arxiv.org/abs/1202.5822) unterliegt das, dass die hamiltona stattdessen in eine Summe von uniflüssen $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{u} \_ j zerlegt wird. \end{align} $ $ WHERE $a \_ j>$0 sind Koeffizienten, und $ \hat{u} \_ j $ sind Uni-.</span><span class="sxs-lookup"><span data-stu-id="63089-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="63089-124">Dann wird davon ausgegangen, dass eine über einen Blackbox-Zugriff auf die einheitliche Oracle-$V = \sum ^ {d-1} \_ {j = 0} \ket{j}\bra{j}\otimes \hat{u} \_ j $ verfügt, der das gewünschte $ \hat{u} j $ auswählt. \_ und die Oracle-$A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ Sum ^ {d-1} \_ {k = 0} \alpha \_ j} \ket{j} $, die einen Quantum-Status zum Codieren dieser Koeffizienten erstellen.</span><span class="sxs-lookup"><span data-stu-id="63089-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="63089-125">Im Fall von [hamiltonan-Simulation](https://arxiv.org/abs/quant-ph/0301023)mit geringer Dichte geht davon aus, dass es sich bei der hamiltonan um eine SparseMatrix mit nur $d = \mathcal{o} (\text{polylog} (N)) $ nicht-NULL-Element in jeder Zeile handelt.</span><span class="sxs-lookup"><span data-stu-id="63089-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="63089-126">Außerdem wird davon ausgegangen, dass effiziente Quantum-Leitungen vorhanden sind, die den Speicherort dieser Elemente ungleich 0 (null) sowie die zugehörigen Werte ausgeben.</span><span class="sxs-lookup"><span data-stu-id="63089-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="63089-127">Die Komplexität von [hamiltona-Simulations Algorithmen](xref:microsoft.quantum.more-information) wird in Bezug auf die Anzahl von Abfragen für diese schwarzen Felder ausgewertet. die Komplexität des primitiven Tors hängt dann sehr stark von der Schwierigkeit der Implementierung dieser schwarzen Felder ab.</span><span class="sxs-lookup"><span data-stu-id="63089-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="63089-128">Die Big-O-Notation wird häufig verwendet, um die Komplexitäts Skalierung von Algorithmen zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="63089-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="63089-129">Bei zwei echten Funktionen $f g $ bedeutet der Ausdruck $g (x) = \mathcal{o} (f (x)) $, dass es eine absolute positive Konstante gibt $x \_ 0, c>$0, sodass $g (x) \le c f (x) $ für alle $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="63089-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="63089-130">In den meisten praktischen Anwendungen, die auf einem Quantum-Computer implementiert werden müssen, müssen diese schwarzen Felder effizient implementiert werden, d. h. mit $ \mathcal{o} (\text{polylog} (N)) $ primitive quantgates.</span><span class="sxs-lookup"><span data-stu-id="63089-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="63089-131">Stärker ist es erforderlich, dass eine effiziente simulier Bare, äußerst geringe, klassische Beschreibung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="63089-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="63089-132">In einer solchen Formulierung wird davon ausgegangen, dass die hamiltona in eine Summe von hermitian-Teilen $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j zerlegt wird.</span><span class="sxs-lookup"><span data-stu-id="63089-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="63089-133">\end{align} $ $ darüber hinaus wird davon ausgegangen, dass jeder Teil, ein hamiltonan $H \_ j $, leicht simuliert werden kann.</span><span class="sxs-lookup"><span data-stu-id="63089-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="63089-134">Dies bedeutet, dass der einheitliche $e ^ {-IH \_ j t} $ für jede Zeit $t $ möglicherweise genau mithilfe von $ \mathcal{o} (1) $ primitiver Quantum-Gates implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="63089-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="63089-135">Dies gilt z. b. für den Sonderfall, dass jede $H \_ j $ lokale Pauli-Operatoren ist, d. h., Sie sind tensorflow-Produkte von $ \mathcal{o} (1) $ Non-Identity-Pauli-Operatoren, die auf räumlich schließende Qubits reagieren.</span><span class="sxs-lookup"><span data-stu-id="63089-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="63089-136">Dieses Modell gilt besonders für physische Systeme mit begrenzter und lokaler Interaktion, da die Anzahl der Begriffe $d = \mathcal{o} (\text{polylog} (N)) $ ist und möglicherweise eindeutig geschrieben ist, d. h. in polynomzeit klassisch beschrieben.</span><span class="sxs-lookup"><span data-stu-id="63089-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="63089-137">Hamiltonane, die in eine Summe von Teilen zerlegt werden, können mithilfe der Dynamical Generator-Darstellungs Bibliothek beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="63089-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="63089-138">Weitere Informationen finden Sie im Abschnitt Dynamical Generator-Darstellung in [Datenstrukturen](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="63089-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="63089-139">Simulations Algorithmen</span><span class="sxs-lookup"><span data-stu-id="63089-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="63089-140">Ein Quantum-Simulations Algorithmus konvertiert eine gegebene Beschreibung eines hamiltonins in eine Sequenz primitiver Quantum-Gates, die als Ganzes eine ungefähre Zeit-Evolution durch den Aufruf von hamiltonan bewirken.</span><span class="sxs-lookup"><span data-stu-id="63089-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="63089-141">Im besonderen Fall, in dem die hamiltona in eine Summe aus hermischen Teilen zerlegt wird, ist die Trotter-Suzuki Zerlegung ein besonders einfacher und intuitiver Algorithmus zum Simulieren von hamiltonen, die in eine Summe von hermitian-Komponenten zerlegt werden.</span><span class="sxs-lookup"><span data-stu-id="63089-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="63089-142">Beispielsweise ein Integrator der ersten Bestellung dieser Familie entspricht $ $ \begin{align} U (t) & = \left (e ^ {-IH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{o} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ mithilfe eines Produkts von $r d $-Begriffen.</span><span class="sxs-lookup"><span data-stu-id="63089-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="63089-143">In den Beispielen werden Anwendungen des Trotter-Suzuki Simulations Algorithmus behandelt.</span><span class="sxs-lookup"><span data-stu-id="63089-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="63089-144">Das Erstellungs Modell, das nur die systeminternen Vorgänge verwendet, die von den einzelnen Ziel Computern bereitgestellt werden, finden Sie im [Beispiel **simpleising**](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="63089-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="63089-145">Informationen zum Strukturierung von Modellen mit der Trotter-Suzuki-Bibliotheks Steuerungsstruktur finden Sie im Beispiel für [ **isingtrotter.**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution)</span><span class="sxs-lookup"><span data-stu-id="63089-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="63089-146">Informationen zu molekularem Wasserstoff mithilfe der Trotter-Suzuki-Bibliotheks Steuerungsstruktur finden Sie im Beispiel für die [ **H2-Simulation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="63089-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="63089-147">In vielen Fällen möchten wir den Simulations Algorithmus implementieren, sind jedoch nicht an den Details der Implementierung interessiert.</span><span class="sxs-lookup"><span data-stu-id="63089-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="63089-148">Beispielsweise der Second-order Integrator entspricht $ $ \begin{align} U (t) & = \left (e ^ {-IH \_ 0 t/2R} e ^ {-IH \_ 1 t/2R} \cdots e ^ {-IH \_ {d-1} t/2R} e ^ {-IH \_ {d-1} t/2R} \cdots e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \right) ^ {r} + \mathcal{o} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ unter Verwendung eines Produkts von $2RD $ Terms.</span><span class="sxs-lookup"><span data-stu-id="63089-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="63089-149">Größere Bestellungen umfassen noch mehr Begriffe, und optimierte Varianten erfordern möglicherweise sehr untriviale Ordnungen in den Exponentialzahlen.</span><span class="sxs-lookup"><span data-stu-id="63089-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="63089-150">Andere erweiterte Algorithmen können auch die Verwendung von "Ancilla Qubits" in Zwischenschritten einschließen.</span><span class="sxs-lookup"><span data-stu-id="63089-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="63089-151">Daher verpacken wir Simulations Algorithmen im Kanon als benutzerdefinierten Typ.</span><span class="sxs-lookup"><span data-stu-id="63089-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="63089-152">Der erste Parameter `Double` ist die Simulationszeit, der zweite Parameter `EvolutionGenerator` , der im Abschnitt "Dynamical Generator Darstellung" der [Datenstrukturen](xref:microsoft.quantum.libraries.data-structures)abgedeckt ist, ist eine klassische Beschreibung einer zeitunabhängigen hamiltona, die eine Anleitung dazu gibt, wie die einzelnen Begriffe in der hamiltonan durch eine Quantum-Verbindung simuliert werden können.</span><span class="sxs-lookup"><span data-stu-id="63089-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="63089-153">Die Typen dieses Formulars nähern sich dem einheitlichen Vorgang $e ^ {-IHT} $ für den dritten Parameter, bei dem es `Qubit[]` sich um das Register handelt, das den Quantenzustand des simulierten Systems speichert.</span><span class="sxs-lookup"><span data-stu-id="63089-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="63089-154">Entsprechend definieren wir bei zeitabhängigen Fällen einen benutzerdefinierten Typ mit einem `EvolutionSchedule` Typ, der eine klassische Beschreibung eines zeitabhängigen hamiltones ist.</span><span class="sxs-lookup"><span data-stu-id="63089-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="63089-155">Beispielsweise kann die Trotter-Suzuki Zerlegung mithilfe der folgenden Funktionen von Canon aufgerufen werden, mit Parametern, `trotterStepSize` die die Dauer der Simulation in den einzelnen exponentialwerte ändern, und `trotterOrder` für die Reihenfolge des gewünschten Integrator.</span><span class="sxs-lookup"><span data-stu-id="63089-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="63089-156">Anwendungen der Simulations Bibliothek werden in den Beispielen behandelt.</span><span class="sxs-lookup"><span data-stu-id="63089-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="63089-157">Informationen zur Phasen Schätzung im ersierenden Modell mithilfe von finden `SimulationAlgorithm` Sie im [Beispiel **isingphaseschätz.**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)</span><span class="sxs-lookup"><span data-stu-id="63089-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="63089-158">Informationen zur Vorbereitung des adiabatischen Zustands im ersierenden Modell mithilfe von finden `TimeDependentSimulationAlgorithm` Sie im Beispiel " [ **adiabaticising**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)".</span><span class="sxs-lookup"><span data-stu-id="63089-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="63089-159">Schätzung der adiabatischen Zustands Vorbereitung & Phasen</span><span class="sxs-lookup"><span data-stu-id="63089-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="63089-160">Eine gängige Anwendung der hamiltonan-Simulation ist die adiabatische Zustands Vorbereitung.</span><span class="sxs-lookup"><span data-stu-id="63089-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="63089-161">Hier wird eine der beiden hamiltonane $H \_ {\text{Start}} $ und $H \_ {\text{End}} $ und der Quantum State $ \ket{\psi (0)} $ bereitgestellt, der den Grundzustand der Start-hamiltona $H \_ {\text{Start}} $ ist.</span><span class="sxs-lookup"><span data-stu-id="63089-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="63089-162">In der Regel wird $H \_ {\text{Start}} $ ausgewählt, sodass $ \ket{\psi (0)} $ leicht aus dem Berechnungsbasis Status $ \ket{0\cdots 0} $ vorbereitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="63089-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="63089-163">Durch die gleich lange Interpolation zwischen diesen hamiltonoren im zeitabhängigen Simulations Problem ist es möglich, mit hoher Wahrscheinlichkeit in einem Grundzustand der abschließenden hamiltonan $H \_ {\text{End}} $ zu enden.</span><span class="sxs-lookup"><span data-stu-id="63089-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="63089-164">Obwohl das Vorbereiten von guten Näherungen an den hamiltona-Boden Status auf diese Weise fortgesetzt werden kann, indem für zeitabhängige hamiltonalgorithmen-Simulations Algorithmen als Unterroutine aufgerufen werden, sind andere konzeptionell unterschiedliche Ansätze wie z. b. die Variational Quantum eigen Solver möglich.</span><span class="sxs-lookup"><span data-stu-id="63089-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="63089-165">Eine andere Anwendung, die in der Quantum-Chemie universell ist, schätzt jedoch die Grund Zustands Energie der hamiltonane, die die Zwischenschritte der chemischen Reaktion darstellen.</span><span class="sxs-lookup"><span data-stu-id="63089-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="63089-166">Ein solches Schema könnte z. b. auf der Vorbereitung des Adiabatic-Zustands basieren, um den Bodenzustand zu erzeugen, und dann zeitunabhängige hamiltoneine Simulation als Unterroutine in der Zeit der Phasen Schätzung einbeziehen, um diese Energie mit einem begrenzten Fehler und einer Erfolgswahrscheinlichkeit zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="63089-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="63089-167">Abstrahieren von Simulations Algorithmen als benutzerdefinierte Typen `SimulationAlgorithm` und `TimeDependentSimulationAlgorithm` ermöglichen es uns, ihre Funktionalität bequem in komplexere Quantum-Algorithmen einzubinden.</span><span class="sxs-lookup"><span data-stu-id="63089-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="63089-168">Dies hat zur Folge, dass wir für diese häufig verwendeten Unterroutinen dasselbe tun müssen.</span><span class="sxs-lookup"><span data-stu-id="63089-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="63089-169">Daher wird die bequeme Funktion definiert.</span><span class="sxs-lookup"><span data-stu-id="63089-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="63089-170">Dadurch wird ein einheitlicher Vorgang zurückgegeben, der alle Schritte der adiabatischen Zustands Vorbereitung implementiert.</span><span class="sxs-lookup"><span data-stu-id="63089-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="63089-171">Der erste Parameter `interpolatedTime` definiert die Zeit, zu der wir eine lineare interpolieren zwischen der vom zweiten Parameter beschriebenen Start-hamiltona `evolutionGeneratorStart` und dem End hamiltona durch den dritten Parameter durchgeführt haben `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="63089-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="63089-172">Der vierte Parameter `timeDependentSimulationAlgorithm` ist die Wahl des Simulations Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="63089-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="63089-173">Beachten Sie, dass `interpolatedTime` , wenn lang genug ist, ein ursprünglicher Ausgangszustand für die gesamte Dauer der zeitabhängigen Simulation ein sofortiger Grundzustand der hamiltona ist und somit den Grundzustand des enden hamiltones endet.</span><span class="sxs-lookup"><span data-stu-id="63089-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="63089-174">Außerdem wird ein hilfreicher Vorgang definiert, der automatisch alle Schritte eines typischen quantumchemie-Experiments ausführt.</span><span class="sxs-lookup"><span data-stu-id="63089-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="63089-175">Zum Beispiel verfügen wir über Folgendes, das eine Energie Schätzung des von der Adiabatic-Zustands Vorbereitung erzeugten Zustands zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="63089-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="63089-176">`nQubits` die Anzahl der Qubits, die zum Codieren des anfänglichen Quantums verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="63089-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="63089-177">`statePrepUnitary` bereitet den Startstatus von der Berechnungsbasis $ \ket{0\cdots 0} $ vor.</span><span class="sxs-lookup"><span data-stu-id="63089-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="63089-178">`adiabaticUnitary` ist der einheitliche Vorgang, der die adiabatische Zustands Vorbereitung implementiert, z. b. durch die-  `InterpolatedEvolution` Funktion erzeugt.</span><span class="sxs-lookup"><span data-stu-id="63089-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="63089-179">`qpeUnitary` der einheitliche Vorgang, der verwendet wird, um die Phasen Schätzung für den resultierenden Quantum-Zustand auszuführen.</span><span class="sxs-lookup"><span data-stu-id="63089-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="63089-180">`phaseEstAlgorithm` ist die Wahl des Algorithmus zur Phasen Schätzung.</span><span class="sxs-lookup"><span data-stu-id="63089-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="63089-181">In den Beispielen werden Anwendungen der Adiabatic-Zustands Vorbereitung behandelt.</span><span class="sxs-lookup"><span data-stu-id="63089-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="63089-182">Informationen zum Erstellungsmodell, das eine manuelle Implementierung der adiabatischen Zustands Vorbereitung und der Verwendung der- `AdiabaticEvolution` Funktion verwendet, finden Sie im Beispiel " [ **adiabaticising**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)".</span><span class="sxs-lookup"><span data-stu-id="63089-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="63089-183">Informationen zur Phasen-und adiabatischen Zustands Vorbereitung im ersierungsmodell finden Sie im [Beispiel **isingphaseschätz.**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)</span><span class="sxs-lookup"><span data-stu-id="63089-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="63089-184">Die [Simulation von molekularer Wasserstoff](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) ist ein interessantes und kurzes Beispiel.</span><span class="sxs-lookup"><span data-stu-id="63089-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="63089-185">Das Modell und die experimentellen Ergebnisse, die in der Datei "" [.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="63089-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="63089-186">erfordert nur die Pauli-Matrizen und hat das Format $ \hat H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {Z \_ 0} + g \_ 2 {z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {y \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="63089-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="63089-187">Dabei handelt es sich um eine effektive hamiltona, die nur 2 Qubits erfordert, bei denen die Konstanten $g $ aus der Entfernung $R $ zwischen den beiden Wasserstoffatomen berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="63089-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="63089-188">Mithilfe von kanonischen Funktionen werden die Paulis in Uni-und dann über kurze Zeiträume mithilfe der Trotter-Suzuki Zerlegung weiterentwickelt.</span><span class="sxs-lookup"><span data-stu-id="63089-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="63089-189">Eine gute Näherung für den $H _2 $ Ground State kann ohne Verwendung der Adiabatic-Zustands Vorbereitung erstellt werden. Daher kann die Grund Zustands Energie direkt durch die Verwendung der Phasen Schätzung vom Kanon gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="63089-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="63089-190">Shor-Algorithmus</span><span class="sxs-lookup"><span data-stu-id="63089-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="63089-191">Der Shor-Algorithmus ist eine der wichtigsten Entwicklungen bei der quantumberechnung, da er zeigte, dass Quantum-Computer verwendet werden könnten, um wichtige, zurzeit klassisch unlösbare Probleme zu lösen.</span><span class="sxs-lookup"><span data-stu-id="63089-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="63089-192">Der Shor-Algorithmus bietet eine schnelle Möglichkeit, um große Zahlen mithilfe eines Quantum-Computers zu berücksichtigen, ein Problem, das als *Factoring* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="63089-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring* .</span></span>
<span data-ttu-id="63089-193">Die Sicherheit vieler vorhandener Kryptosysteme basiert auf der Annahme, dass kein schneller Algorithmus für das Factoring vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="63089-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="63089-194">Daher hat der Shor-Algorithmus einen tiefgreifenden Einfluss auf die Sicherheit in einer Post-Quantum-Welt.</span><span class="sxs-lookup"><span data-stu-id="63089-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="63089-195">Der Shor-Algorithmus kann als Hybrid Algorithmus betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="63089-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="63089-196">Der Quantum-Computer wird verwendet, um eine Rechen harte Aufgabe auszuführen, die als Zeitraum der Suche bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="63089-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="63089-197">Die Ergebnisse aus der Zeitraum Suche werden dann klassisch verarbeitet, um die Faktoren einzuschätzen.</span><span class="sxs-lookup"><span data-stu-id="63089-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="63089-198">Wir überprüfen diese beiden Schritte unten.</span><span class="sxs-lookup"><span data-stu-id="63089-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="63089-199">Suche nach Zeitraum</span><span class="sxs-lookup"><span data-stu-id="63089-199">Period Finding</span></span> ###

<span data-ttu-id="63089-200">Nachdem Sie gesehen haben, wie die Quantum Fourier-Transformation und-Phasen Schätzung funktionieren (siehe [Quantum-Algorithmen](xref:microsoft.quantum.libraries.standard.algorithms)), können wir diese Tools verwenden, um ein klassisches, schwer wiesendes Problem mit dem Namen " *Zeit Suche* "</span><span class="sxs-lookup"><span data-stu-id="63089-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding* .</span></span>  <span data-ttu-id="63089-201">Im nächsten Abschnitt erfahren Sie, wie Sie die Zeitspanne für das Factoring anwenden.</span><span class="sxs-lookup"><span data-stu-id="63089-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="63089-202">Bei zwei Ganzzahlen $a $ und $N $, bei denen $a<N $, das Ziel der Zeit Steuerungs Suche (auch als Bestellsuche bezeichnet) ist, die _Reihenfolge_ $r $ of $a $ modulo $N $ zu finden, wobei $r $ als die geringste positive Ganzzahl definiert ist, die $a ^ r \equiv 1 \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="63089-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="63089-203">Zum Ermitteln der Bestellung mithilfe eines Quantum-Computers wir können den Phasen Schätz Algorithmus verwenden, der auf den folgenden einheitlichen Operator angewendet wird $U _A $: $ $ U_a \ket{x} \equiv \ket{(AX) \text{mod} N}. $ $ die Eigenvektoren $U _A $ gelten für Integer $s $ und $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\bruchteil {-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ sind _eigen Zustände_ der $U _A $.</span><span class="sxs-lookup"><span data-stu-id="63089-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="63089-204">Die Eigenwerte $U _A $ sind $ $ U \_ a \ket{x \_ s} = e ^ {2 \ Pi i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="63089-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="63089-205">Bei der Phasen Schätzung werden daher die Eigenwerte $e ^ {2 \ Pi i s/r} $ ausgegeben, aus denen $r $ mithilfe der [fortgesetzten Bruch](https://en.wikipedia.org/wiki/Continued_fraction) Zahlen von $s/r $ effizient erlernt werden kann.</span><span class="sxs-lookup"><span data-stu-id="63089-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="63089-206">Das Verbindungs Diagramm für das Auffinden von Quantum-Perioden lautet:</span><span class="sxs-lookup"><span data-stu-id="63089-206">The circuit diagram for quantum period finding is:</span></span>

![Verbindungs Diagramm für die Suche nach Quantum-Zeit](~/media/QPE.svg)

<span data-ttu-id="63089-208">Hier werden $2N $ Qubits mit "$ \ket $" initialisiert, {0} und $n $ Qubits werden mit "$ \ket $" initialisiert {1} .</span><span class="sxs-lookup"><span data-stu-id="63089-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="63089-209">Der Reader kann sich vielleicht Fragen, warum das Quantum-Register zum Speichern der Eigen Zustände mit "$ \ket $" initialisiert wird {1} .</span><span class="sxs-lookup"><span data-stu-id="63089-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="63089-210">Da die Reihenfolge $r $ im Voraus nicht bekannt ist, können wir $ \ket{x_s} $ States nicht direkt vorbereiten.</span><span class="sxs-lookup"><span data-stu-id="63089-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="63089-211">Glücklicherweise hat sich herausstellt, dass $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $ ist.</span><span class="sxs-lookup"><span data-stu-id="63089-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="63089-212">Wir müssen $ \ket{x} $! nicht tatsächlich vorbereiten.</span><span class="sxs-lookup"><span data-stu-id="63089-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="63089-213">Wir können einfach ein Quantum-Register von $n $ Qubits im Status $ \ket {1} $ vorbereiten.</span><span class="sxs-lookup"><span data-stu-id="63089-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="63089-214">Die Verbindung enthält den QFT und mehrere kontrollierte Gates.</span><span class="sxs-lookup"><span data-stu-id="63089-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="63089-215">Das QFT-Gate wurde [zuvor](xref:microsoft.quantum.libraries.standard.algorithms)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="63089-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="63089-216">Der gesteuerte $U _A $ Gate ordnet $ \ket{x} $ zu $ \ket{(AX) \text{mod} N} $ zu, wenn das Steuerelement-Qubit $ \ket {1} $ ist, und ordnet $ \ket{x} $ auf $ \ket{x} $ zu.</span><span class="sxs-lookup"><span data-stu-id="63089-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="63089-217">Um $ (a ^ NX) \text{mod} n $ zu erreichen, können wir einfach "gesteuerte-$U _ {a ^ n} $" anwenden, wobei wir $a ^ N \text{mod} n $ klassisch berechnen, um in die Quantum-Leitung zu gelangen.</span><span class="sxs-lookup"><span data-stu-id="63089-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="63089-218">Die Verbindungen, um eine solche Modulare Arithmetik zu erzielen, wurden in der Dokumentation für die [Quantum-Arithmetik](./algorithms.md#arithmetic)beschrieben. insbesondere benötigen wir eine modulare exponentiations Verbindung, um die kontrollierten $U \_ {a ^ i} $-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="63089-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="63089-219">Die obige Verbindung entspricht der [Quantum-Phasen-Schätzung](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) und ermöglicht das explizite Sortieren der Reihenfolge. die Anzahl der benötigten Qubits kann reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="63089-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="63089-220">Wir können die-Methode von Beauregard für die Bestellsuche befolgen, wie [auf Seite 8 von arXiv: quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)beschrieben, oder Sie können eine der Phasen Schätz Routinen verwenden, die in Microsoft. Quantum. Charakterisierung verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="63089-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="63089-221">Beispielsweise wird bei der [robusten Phasen Schätzung](xref:microsoft.quantum.characterization.robustphaseestimation) auch ein zusätzliches Qubit verwendet.</span><span class="sxs-lookup"><span data-stu-id="63089-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="63089-222">Berücksichtigung</span><span class="sxs-lookup"><span data-stu-id="63089-222">Factoring</span></span> ###
<span data-ttu-id="63089-223">Das Ziel der Factoring besteht darin, die beiden Hauptfaktoren der ganzzahligen $N $ zu ermitteln, wobei $N $ eine $n $-Bit-Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="63089-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="63089-224">Das Factoring besteht aus den unten beschriebenen Schritten.</span><span class="sxs-lookup"><span data-stu-id="63089-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="63089-225">Die Schritte sind in drei Teile unterteilt: eine klassische Vorverarbeitungs Routine (1-4); eine Quantum Computing-Routine zum Ermitteln der Reihenfolge $a \text{mod} N $ (5); und eine klassische nachträglich verarbeitetes-Routine zur Ableitung der Prim Faktoren aus der Reihenfolge (6-9).</span><span class="sxs-lookup"><span data-stu-id="63089-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="63089-226">Die klassische Vorverarbeitungs Routine besteht aus den folgenden Schritten:</span><span class="sxs-lookup"><span data-stu-id="63089-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="63089-227">Wenn $N $ gleich ist, wird der Primfaktor $2 $ zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63089-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="63089-228">Wenn $N = p ^ q $ for $p \geq1 $, $q \geq2 $, wird der Primfaktor $p $ zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63089-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="63089-229">Dieser Schritt wird klassisch ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="63089-229">This step is performed classically.</span></span>
3. <span data-ttu-id="63089-230">Wählen Sie eine Zufallszahl $a $ aus, sodass $1 < ein < N-$1.</span><span class="sxs-lookup"><span data-stu-id="63089-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="63089-231">Wenn $ \text{GCD} (a, n) >$1, wird der Prim Faktor $ \text{GCD} (a, N) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63089-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="63089-232">Dieser Schritt wird mit dem Algorithmus von Euclid berechnet.</span><span class="sxs-lookup"><span data-stu-id="63089-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="63089-233">Wenn kein Prim Faktor zurückgegeben wurde, fahren wir mit der Quantum-Routine fort:</span><span class="sxs-lookup"><span data-stu-id="63089-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="63089-234">Aufrufen des Algorithmus zum Ermitteln der Quantum-Zeitspanne, um die Reihenfolge $r $ of $a \text{mod} N $ zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="63089-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="63089-235">Verwenden Sie $r $ in der klassischen nachträglich verarbeitetes-Routine, um die wichtigsten Faktoren zu ermitteln:</span><span class="sxs-lookup"><span data-stu-id="63089-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="63089-236">Wenn $r $ ungerade ist, wechseln Sie zurück zum Vorverarbeitungs Schritt (3).</span><span class="sxs-lookup"><span data-stu-id="63089-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="63089-237">Wenn $r $ gleich ist, und $a ^ {r/2} =-1 \ Text {mod} N $, gehen Sie zurück zum Vorverarbeitungs Schritt (3).</span><span class="sxs-lookup"><span data-stu-id="63089-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="63089-238">Wenn $ \text{GCD} (a ^ {r/2} + 1, n) $ ein nicht trivialer Faktor $N $ ist, wird $ \text{GCD} (a ^ {r/2} + 1, n) $ zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63089-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="63089-239">Wenn $ \text{GCD} (a ^ {r/2}-1, n) $ ein nicht trivialer Faktor $N $ ist, wird $ \text{GCD} (a ^ {r/2}-1, n) $ zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63089-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="63089-240">Der Factoring-Algorithmus ist probabilistisch: Es kann angezeigt werden, dass die Wahrscheinlichkeit mindestens eine Hälfte ist, dass $r $ gleich ist, und $a ^ {r/2} \netq-1 \text{mod} N $, wodurch ein Prim Faktor erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="63089-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="63089-241">( [Weitere Informationen](xref:microsoft.quantum.more-information)finden Sie im [Originalartikel von Shor](https://doi.org/10.1109/SFCS.1994.365700) oder einem der *grundlegenden Quantum Computing* -Texte in.)</span><span class="sxs-lookup"><span data-stu-id="63089-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="63089-242">Wenn kein Prim Faktor zurückgegeben wird, wiederholen Sie einfach den Algorithmus aus Schritt (1).</span><span class="sxs-lookup"><span data-stu-id="63089-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="63089-243">Nach $n $ tries beträgt die Wahrscheinlichkeit, dass jeder Versuch fehlgeschlagen ist, höchstens $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="63089-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="63089-244">Daher ist es nach dem Wiederholen des Algorithmus sehr gering, dass der Erfolg praktisch sicher ist.</span><span class="sxs-lookup"><span data-stu-id="63089-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
